{"version":3,"file":"index-B9MaYYXO.js","sources":["../../src/scenes/BootScene.ts","../../src/assets/juan/animations/juan_gorilla_idle.png","../../src/assets/juan/animations/juan_gorilla_running.png","../../src/assets/juan/animations/juan_gorilla_jumping.png","../../src/assets/juan/animations/juan_gorilla_punch.png","../../src/assets/juan/animations/juan_gorilla_uppercut.png","../../src/assets/juan/animations/juan_gorilla_aerial_punch.png","../../src/assets/juan/animations/juan_gorilla_getting_punched.png","../../src/assets/juan/animations/juan_getting_punched_stomach.png","../../src/assets/juan/animations/juan_dodge_punch_animation.png","../../src/assets/juan/animations/juan_matrix_style_dodge.png","../../src/assets/juan/animations/juan_kipup_animation.png","../../src/assets/audio/punch.mp3","../../src/assets/audio/kick.mp3","../../src/assets/audio/power-up.wav","../../src/assets/audio/menu_music.mp3","../../src/assets/backgrounds/server_lab.png","../../src/assets/backgrounds/overgrown_city.png","../../src/assets/backgrounds/overgrown_city_sunset.png","../../src/assets/backgrounds/versus.png","../../src/assets/juan_sidekick_main_menu.png","../../src/assets/props/platforms/server_lab_floor.png","../../src/assets/props/platforms/overgrown_ground_floor.png","../../src/assets/props/platforms/overgrown_floating_platform_350.png","../../src/assets/props/platforms/floating_scaffolding.png","../../src/assets/props/powerups/power-booster.png","../../src/assets/enemy_human/enemy_blockhead_idle.png","../../src/assets/enemy_human/enemy_blockhead_running.png","../../src/assets/enemy_human/enemy_blockhead_punch.png","../../src/assets/enemy_human/enemy_blockhead_sidekick.png","../../src/assets/enemy_human/enemy_blockhead_getting_punched.png","../../src/scenes/PreloadScene.ts","../../src/scenes/MenuScene.ts","../../src/entities/Player.ts","../../src/entities/Enemy.ts","../../src/entities/PowerBooster.ts","../../src/systems/InputManager.ts","../../src/ui/BoosterBar.ts","../../src/ui/PauseMenu.ts","../../src/ui/HealthBar.ts","../../src/ui/GameOverOverlay.ts","../../src/ai/EnemyAIController.ts","../../src/scenes/GameScene.ts","../../src/scenes/VersusScene.ts","../../src/scenes/StoryScene.ts","../../src/scenes/CreditsScene.ts","../../src/config/GameConfig.ts","../../src/main.ts"],"sourcesContent":["/**\n * Boot Scene\n * ===========\n * First scene to run. Sets up minimal assets and transitions to PreloadScene.\n */\n\nimport Phaser from 'phaser';\n\nexport class BootScene extends Phaser.Scene {\n  constructor() {\n    super({ key: 'Boot' });\n  }\n\n  preload(): void {\n    // Future: Load loading bar assets here\n  }\n\n  create(): void {\n    console.log('[BootScene] Game booting...');\n    this.scene.start('Preload');\n  }\n}\n","export default \"__VITE_ASSET__lfpvyzxP__\"","export default \"__VITE_ASSET__BfaIG6b1__\"","export default \"__VITE_ASSET__B7EDBydQ__\"","export default \"__VITE_ASSET__aCdRTa1d__\"","export default \"__VITE_ASSET__CBEMCEUa__\"","export default \"__VITE_ASSET__pOdFKSpD__\"","export default \"__VITE_ASSET__B5nxSdig__\"","export default \"__VITE_ASSET__DsQlKKPB__\"","export default \"__VITE_ASSET__D0o9306I__\"","export default \"__VITE_ASSET__UylDc$72__\"","export default \"__VITE_ASSET__BZ8OX4mm__\"","export default \"__VITE_ASSET__BeSfFMzS__\"","export default \"__VITE_ASSET__BDX3n2FC__\"","export default \"__VITE_ASSET__DvjNmNX4__\"","export default \"__VITE_ASSET__DYFkx2Uw__\"","export default \"__VITE_ASSET__CDqeirRX__\"","export default \"__VITE_ASSET__DGG0mYMN__\"","export default \"__VITE_ASSET__ziMKV6$4__\"","export default \"__VITE_ASSET__BLQlohyP__\"","export default \"__VITE_ASSET__CGsyE2N8__\"","export default \"__VITE_ASSET__CxbtmX0l__\"","export default \"__VITE_ASSET__CEnzb9yH__\"","export default \"__VITE_ASSET__jngmsKR___\"","export default \"__VITE_ASSET__CCmMqvef__\"","export default \"__VITE_ASSET__DMiuTL0u__\"","export default \"__VITE_ASSET___yIrxtAY__\"","export default \"__VITE_ASSET__Ck9ZKSPY__\"","export default \"__VITE_ASSET__DEdIyKX4__\"","export default \"__VITE_ASSET__Y1Zs0B6$__\"","export default \"__VITE_ASSET__C8R_BNbP__\"","/**\n * Preload Scene\n * ==============\n * Loads all game assets with a progress bar.\n */\n\nimport Phaser from 'phaser';\nimport { GAME_WIDTH, GAME_HEIGHT } from '../config/GameConfig';\n\n// Import assets using Vite's asset handling (returns resolved URLs)\nimport juanIdleUrl from '../assets/juan/animations/juan_gorilla_idle.png';\nimport juanRunUrl from '../assets/juan/animations/juan_gorilla_running.png';\nimport juanJumpUrl from '../assets/juan/animations/juan_gorilla_jumping.png';\nimport juanPunchUrl from '../assets/juan/animations/juan_gorilla_punch.png';\nimport juanUppercutUrl from '../assets/juan/animations/juan_gorilla_uppercut.png';\nimport juanAerialPunchUrl from '../assets/juan/animations/juan_gorilla_aerial_punch.png';\nimport juanGettingPunchedUrl from '../assets/juan/animations/juan_gorilla_getting_punched.png';\nimport juanGettingPunchedStomachUrl from '../assets/juan/animations/juan_getting_punched_stomach.png';\nimport juanDodgeUrl from '../assets/juan/animations/juan_dodge_punch_animation.png';\nimport juanMatrixDodgeUrl from '../assets/juan/animations/juan_matrix_style_dodge.png';\nimport juanKipupUrl from '../assets/juan/animations/juan_kipup_animation.png';\n\n// Audio\nimport punchSfxUrl from '../assets/audio/punch.mp3';\nimport kickSfxUrl from '../assets/audio/kick.mp3';\nimport powerUpSfxUrl from '../assets/audio/power-up.wav';\nimport menuMusicUrl from '../assets/audio/menu_music.mp3';\n\n// Backgrounds\nimport serverLabBgUrl from '../assets/backgrounds/server_lab.png';\nimport overgrownCityBgUrl from '../assets/backgrounds/overgrown_city.png';\nimport overgrownCitySunsetBgUrl from '../assets/backgrounds/overgrown_city_sunset.png';\nimport versusBgUrl from '../assets/backgrounds/versus.png';\n\n// Menu assets\nimport juanMenuUrl from '../assets/juan_sidekick_main_menu.png';\n\n// Props - Platforms\nimport serverLabFloorUrl from '../assets/props/platforms/server_lab_floor.png';\nimport overgrownGroundFloorUrl from '../assets/props/platforms/overgrown_ground_floor.png';\nimport overgrownFloatingPlatformUrl from '../assets/props/platforms/overgrown_floating_platform_350.png';\nimport floatingScaffoldingUrl from '../assets/props/platforms/floating_scaffolding.png';\n\n// Props - Powerups\nimport powerBoosterUrl from '../assets/props/powerups/power-booster.png';\n\n// Enemy sprites\nimport enemyIdleUrl from '../assets/enemy_human/enemy_blockhead_idle.png';\nimport enemyRunningUrl from '../assets/enemy_human/enemy_blockhead_running.png';\nimport enemyPunchUrl from '../assets/enemy_human/enemy_blockhead_punch.png';\nimport enemySidekickUrl from '../assets/enemy_human/enemy_blockhead_sidekick.png';\nimport enemyGettingPunchedUrl from '../assets/enemy_human/enemy_blockhead_getting_punched.png';\n\nexport class PreloadScene extends Phaser.Scene {\n  constructor() {\n    super({ key: 'Preload' });\n  }\n\n  preload(): void {\n    this.createLoadingBar();\n\n    // Load Juan's sprite sheets (using Vite-imported URLs)\n    // All sprites now use standardized 200x400 frame size\n\n    // idle: 1200x1200, 6 columns x 3 rows, 6 frames used (row 1)\n    this.load.spritesheet('juan-idle', juanIdleUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // running: 1200x1200, 6 columns x 3 rows, 12 frames used (rows 1-2)\n    this.load.spritesheet('running-animation', juanRunUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // jumping: 1200x400, 6 columns x 1 row, 6 frames\n    this.load.spritesheet('juan-jump', juanJumpUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // punch: 6 standard frames (guard, wind-up, jab, impact, retract, recovery)\n    this.load.spritesheet('juan-punch', juanPunchUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // uppercut: 5 frames\n    this.load.spritesheet('juan-uppercut', juanUppercutUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // aerial punch: 4 frames horizontal strip\n    this.load.spritesheet('juan-aerial-punch', juanAerialPunchUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // getting punched: 5 frames horizontal strip (hurt/damage reaction)\n    this.load.spritesheet('juan-getting-punched', juanGettingPunchedUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // getting punched stomach: 4 frames horizontal strip (gut punch reaction)\n    this.load.spritesheet('juan-getting-punched-stomach', juanGettingPunchedStomachUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // dodge: 4 frames horizontal strip (evasion animation)\n    this.load.spritesheet('juan-dodge', juanDodgeUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // matrix dodge: 12 frame slots (0-11), frames 4-11 are 4 wide frames (400px each)\n    // Layout: frames 0-3 (200px each) | frames 4&5 (400px) on row 1\n    //         frames 6&7 (400px) | frames 8&9 (400px) | frames 10&11 (400px) on row 2\n    this.load.spritesheet('juan-matrix-dodge', juanMatrixDodgeUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // kipup dodge: 1200x800 image, 6 columns x 2 rows, ~10 frames used\n    // Acrobatic dodge where Juan kicks up from the ground\n    this.load.spritesheet('juan-kipup', juanKipupUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n\n    // Load audio\n    this.load.audio('punch-sfx', punchSfxUrl);\n    this.load.audio('kick-sfx', kickSfxUrl);\n    this.load.audio('power-up-sfx', powerUpSfxUrl);\n    this.load.audio('menu-music', menuMusicUrl);\n\n    // Load backgrounds\n    this.load.image('bg-server-lab', serverLabBgUrl);\n    this.load.image('bg-overgrown-city', overgrownCityBgUrl);\n    this.load.image('bg-overgrown-city-sunset', overgrownCitySunsetBgUrl);\n    this.load.image('versus-bg', versusBgUrl);\n\n    // Load menu assets\n    this.load.image('juan-menu', juanMenuUrl);\n\n    // Load props - platforms\n    this.load.image('floor-server-lab', serverLabFloorUrl);\n    this.load.image('floor-overgrown-city', overgrownGroundFloorUrl);\n    this.load.image('floating-platform', overgrownFloatingPlatformUrl);\n    this.load.image('floating-scaffolding', floatingScaffoldingUrl);\n\n    // Load props - powerups\n    this.load.image('power-booster', powerBoosterUrl);\n\n    // Load enemy sprite sheets\n    // enemy_idle: 3 frames in a row\n    this.load.spritesheet('enemy-idle', enemyIdleUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // enemy_running: 1200Ã—1200 sheet, 8 frames (6 on top row, 2 on bottom row)\n    this.load.spritesheet('enemy-running', enemyRunningUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // enemy_punch: 5 frames in a row (frames 4 and 5 are the same, will be combined)\n    this.load.spritesheet('enemy-punch', enemyPunchUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // enemy_sidekick: 4x2 grid (8 slots), last 2 poses are double-width (slots 4+5 and 6+7)\n    this.load.spritesheet('enemy-sidekick', enemySidekickUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n    // enemy_getting_punched: 5 frames horizontal strip (hurt/damage reaction)\n    this.load.spritesheet('enemy-getting-punched', enemyGettingPunchedUrl, {\n      frameWidth: 200,\n      frameHeight: 400,\n    });\n  }\n\n  private createLoadingBar(): void {\n    const barWidth = 400;\n    const barHeight = 30;\n    const barX = (GAME_WIDTH - barWidth) / 2;\n    const barY = (GAME_HEIGHT - barHeight) / 2;\n\n    const bgBar = this.add.graphics();\n    bgBar.fillStyle(0x333333, 1);\n    bgBar.fillRect(barX, barY, barWidth, barHeight);\n\n    const progressBar = this.add.graphics();\n\n    const loadingText = this.add.text(GAME_WIDTH / 2, barY - 30, 'Loading...', {\n      fontFamily: 'Arial',\n      fontSize: '24px',\n      color: '#ffffff',\n    });\n    loadingText.setOrigin(0.5);\n\n    const percentText = this.add.text(GAME_WIDTH / 2, barY + barHeight / 2, '0%', {\n      fontFamily: 'Arial',\n      fontSize: '18px',\n      color: '#ffffff',\n    });\n    percentText.setOrigin(0.5);\n\n    this.load.on('progress', (value: number) => {\n      progressBar.clear();\n      progressBar.fillStyle(0x4ade80, 1);\n      progressBar.fillRect(barX, barY, barWidth * value, barHeight);\n      percentText.setText(`${Math.round(value * 100)}%`);\n    });\n\n    this.load.on('complete', () => {\n      progressBar.destroy();\n      bgBar.destroy();\n      loadingText.destroy();\n      percentText.destroy();\n    });\n  }\n\n  create(): void {\n    console.log('[PreloadScene] All assets loaded!');\n\n    // Generate particle texture for menu effects\n    const particleGfx = this.add.graphics();\n    particleGfx.fillStyle(0xffffff, 1);\n    particleGfx.fillCircle(4, 4, 4);\n    particleGfx.generateTexture('particle', 8, 8);\n    particleGfx.destroy();\n\n    // Set LINEAR filter for juan-menu\n    this.textures.get('juan-menu').setFilter(Phaser.Textures.FilterMode.LINEAR);\n\n    // Set LINEAR filtering for smooth scaling of detailed artwork\n    this.textures.get('juan-idle').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('running-animation').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('juan-jump').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('juan-punch').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('juan-uppercut').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('juan-aerial-punch').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('juan-getting-punched').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('juan-getting-punched-stomach').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('juan-dodge').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('juan-matrix-dodge').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('juan-kipup').setFilter(Phaser.Textures.FilterMode.LINEAR);\n\n    // Enemy textures\n    this.textures.get('enemy-idle').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('enemy-running').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('enemy-punch').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('enemy-sidekick').setFilter(Phaser.Textures.FilterMode.LINEAR);\n    this.textures.get('enemy-getting-punched').setFilter(Phaser.Textures.FilterMode.LINEAR);\n\n    // Add custom wide frame for enemy punch (frames 3+4 combined = 400px wide)\n    // Frames 3 and 4 are the same, so combine them into a single wide frame\n    const enemyPunchTexture = this.textures.get('enemy-punch');\n    enemyPunchTexture.add('punch_extend', 0, 600, 0, 400, 400); // frames 3+4: x=600, y=0, width=400, height=400\n\n    // Add custom wide frames for enemy sidekick (slots 4+5 and 6+7 are 400px wide)\n    const enemySidekickTexture = this.textures.get('enemy-sidekick');\n    enemySidekickTexture.add('kick_extend', 0, 600, 0, 400, 400);   // slots 4+5: x=0, y=400, width=400, height=400\n    enemySidekickTexture.add('kick_follow', 0, 0, 400, 400, 400); // slots 6+7: x=400, y=400, width=400, height=400\n\n    // Add custom wide frames for aerial punch (frames 1+2 and 3+4 are 400px wide each)\n    // Layout: frame0 (200px) | frames1+2 (400px) | frames3+4 (400px) | frame5 (200px)\n    const aerialPunchTexture = this.textures.get('juan-aerial-punch');\n    aerialPunchTexture.add('windup', 0, 200, 0, 400, 400);    // frames 1+2: x=200, y=0, width=400\n    aerialPunchTexture.add('punch', 0, 600, 0, 400, 400);     // frames 3+4: x=600, y=0, width=400\n\n    // Add custom wide frames for matrix dodge\n    // Layout (1200x800): Row 1: frames 0-3 (200px each) + frames 4&5 (400px)\n    //                    Row 2: frames 6&7 (400px) + frames 8&9 (400px) + frames 10&11 (400px)\n    const matrixDodgeTexture = this.textures.get('juan-matrix-dodge');\n    matrixDodgeTexture.add('lean_deep', 0, 600, 0, 400, 400);     // frames 4&5: x=800, y=0, width=400\n    matrixDodgeTexture.add('crouch_1', 0, 0, 400, 400, 400);      // frames 6&7: x=0, y=400, width=400\n\n    // Wait for custom fonts to be fully loaded before starting menu\n    this.waitForFonts().then(() => {\n      this.time.delayedCall(200, () => {\n        this.scene.start('Versus');\n      });\n    });\n  }\n\n  private async waitForFonts(): Promise<void> {\n    // Preload fonts by creating temporary text elements\n    const fontsToLoad = ['Quantico', 'Russo One'];\n    \n    // Create hidden elements to trigger font loading\n    for (const font of fontsToLoad) {\n      const testText = document.createElement('span');\n      testText.style.fontFamily = font;\n      testText.style.position = 'absolute';\n      testText.style.visibility = 'hidden';\n      testText.textContent = 'Font preload test';\n      document.body.appendChild(testText);\n      \n      // Clean up after a moment\n      setTimeout(() => testText.remove(), 100);\n    }\n\n    // Wait for all fonts to be ready\n    if (document.fonts && document.fonts.ready) {\n      await document.fonts.ready;\n      console.log('[PreloadScene] Fonts loaded successfully');\n    }\n  }\n}\n","/**\n * Menu Scene\n * ===========\n * Main menu screen with title, tech-style buttons, and Juan's animated entrance.\n */\n\nimport Phaser from 'phaser';\nimport { GAME_WIDTH, GAME_HEIGHT } from '../config/GameConfig';\n\ninterface MenuButton {\n  frame: Phaser.GameObjects.Graphics;\n  text: Phaser.GameObjects.Text;\n  action: () => void;\n  label: string;\n  hitArea: Phaser.GameObjects.Rectangle;\n}\n\nexport class MenuScene extends Phaser.Scene {\n  private buttons: MenuButton[] = [];\n  private selectedIndex: number = 0;\n  private menuMusic?: Phaser.Sound.BaseSound;\n  private canNavigate: boolean = true;\n  private isMuted: boolean = false;\n  private muteButton?: Phaser.GameObjects.Text;\n  private juanSprite?: Phaser.GameObjects.Image;\n  private swooshGraphics?: Phaser.GameObjects.Graphics;\n  private buttonParticles?: Phaser.GameObjects.Particles.ParticleEmitter;\n  private buttonContainer?: Phaser.GameObjects.Graphics;\n  private buttonGroup?: Phaser.GameObjects.Container;\n\n  // Button styling constants\n  private readonly BUTTON_WIDTH = 350;\n  private readonly BUTTON_HEIGHT = 80;\n  private readonly BUTTON_X = GAME_WIDTH - 550; // Position buttons on the right side\n  private readonly BUTTON_Y_START = 250;\n  private readonly BUTTON_SPACING = 125;\n  private readonly JUAN_FINAL_X = 400;\n\n  private readonly TITLE_FONT_SIZE = '90px';\n  private readonly TITLE_FONT_FAMILY = 'Quantico';\n  private readonly TITLE_NAME = 'HUMANS VS BOTS';\n\n  constructor() {\n    super({ key: 'Menu' });\n  }\n\n  create(): void {\n    console.log('[MenuScene] Showing main menu');\n\n    // Reset state\n    this.buttons = [];\n    this.selectedIndex = 0;\n\n    // Load mute state from registry (persists across scenes)\n    this.isMuted = this.registry.get('musicMuted') || false;\n\n    // Create background with dim overlay\n    this.createBackground();\n\n    // Create floating particles\n    this.createParticles();\n\n    // Start background music (loop if not already playing)\n    this.startMenuMusic();\n\n    // Create title\n    this.createTitle();\n\n    // Create buttons (left side)\n    this.createButtons();\n\n    // Create particles for selected button\n    this.createButtonParticles();\n\n    // Create red selection overlay button\n    // this.createSelectionOverlay();\n\n    // Create Juan sprite with swoosh and entrance animation (right side)\n    this.createJuanEntrance();\n\n    // Create mute button\n    this.createMuteButton();\n\n    // Set up keyboard navigation\n    this.setupKeyboardNavigation();\n\n    // Initial selection highlight\n    this.updateSelection();\n  }\n\n  private createBackground(): void {\n    // Add background image\n    const bg = this.add.image(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'bg-server-lab');\n    bg.setDisplaySize(GAME_WIDTH, GAME_HEIGHT);\n    bg.setDepth(-100);\n\n    // Add blur effect to background\n    bg.preFX?.addBlur(0, 3, 3, 0.3);\n\n    // Add lighter dim overlay to keep neon colors more visible\n    const overlay = this.add.graphics();\n    overlay.fillStyle(0x000000, 0.35);\n    overlay.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n    overlay.setDepth(-99);\n\n    // Add subtle vignette (darker edges) - reduced intensity\n    const vignette = this.add.graphics();\n    for (let i = 0; i < 40; i++) {\n      const alpha = (i / 50) * 0.3;\n      const size = Math.max(GAME_WIDTH, GAME_HEIGHT) * (0.65 + i / 100);\n      vignette.lineStyle(15, 0x000000, alpha);\n      vignette.strokeRect(\n        (GAME_WIDTH - size) / 2,\n        (GAME_HEIGHT - size) / 2,\n        size,\n        size\n      );\n    }\n    vignette.setDepth(-98);\n  }\n\n  private createParticles(): void {\n    // Add floating particle effect with glow\n    const particles = this.add.particles(0, 0, 'particle', {\n      x: { min: this.JUAN_FINAL_X - 250, max: this.JUAN_FINAL_X + 250 },\n      y: { min: GAME_HEIGHT / 3, max: GAME_HEIGHT + 50 },\n      speedY: { min: -30, max: -60 },\n      speedX: { min: -10, max: 10 },\n      lifespan: 6000,\n      quantity: 1,\n      frequency: 150,\n      alpha: { start: 0.4, end: 0 }, // Brighter alpha\n      scale: { start: 0.7, end: 0.2 }, // Slightly larger for more presence\n      tint: [0xbbf7d0, 0xbae6fd], // Very light green and very light skyblue\n      blendMode: Phaser.BlendModes.ADD, // Additive blend for glow effect\n    });\n    particles.setDepth(-50);\n\n    // Add glow post-processing effect to the particles\n    particles.postFX?.addGlow(0xffffff, 4, 0, false, 0.5, 16);\n  }\n\n  private createTitle(): void {\n    // Main title with white text and black outline\n    const title = this.add.text(GAME_WIDTH / 2, 70, this.TITLE_NAME, {\n      fontFamily: this.TITLE_FONT_FAMILY,\n      fontSize: this.TITLE_FONT_SIZE,\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 8,\n      shadow: {\n        offsetX: 2,\n        offsetY: 6,\n        color: '#000000',\n        blur: 1,\n        stroke: true,\n        fill: true,\n      },\n    });\n    title.setOrigin(0.5);\n    title.setDepth(10);\n\n    // Add postFX glow effect to the title\n    title.postFX?.addGlow(0x4ade80, 3, 0, false, 0.4, 16);\n  }\n\n  private createButtons(): void {\n    // Create a container for all button elements to animate together\n    this.buttonGroup = this.add.container(0, 0);\n    this.buttonGroup.setDepth(8);\n\n    // Draw subtle container frame around all buttons (add to group)\n    this.drawButtonContainer();\n\n    const buttonLabels = ['FIGHT', 'STORY', 'CREDITS'];\n\n    buttonLabels.forEach((label, index) => {\n      const y = this.BUTTON_Y_START + index * this.BUTTON_SPACING;\n      const centerX = this.BUTTON_X + this.BUTTON_WIDTH / 2;\n      const centerY = y;\n\n      // Create frame graphics\n      const frame = this.add.graphics();\n      frame.setDepth(9);\n\n      // Create button text\n      const buttonText = this.add.text(centerX, centerY, label, {\n        fontFamily: 'Quantico',\n        fontSize: '60px',\n        color: '#ffffff',\n        stroke: '#000000',\n        strokeThickness: 6,\n      });\n      buttonText.setOrigin(0.5);\n      buttonText.setDepth(11);\n      \n\n      // Create invisible hit area for mouse interaction\n      const hitArea = this.add.rectangle(\n        centerX,\n        centerY,\n        this.BUTTON_WIDTH,\n        this.BUTTON_HEIGHT,\n        0x000000,\n        0\n      );\n      hitArea.setInteractive({ useHandCursor: true });\n      hitArea.setDepth(12);\n\n      // Define action for each button\n      let action: () => void;\n      if (label === 'FIGHT') {\n        action = () => this.startGame();\n      } else if (label === 'STORY') {\n        action = () => this.scene.start('Story');\n      } else {\n        action = () => this.scene.start('Credits');\n      }\n      buttonText.setScale(1, 1);\n      // Mouse hover\n      hitArea.on('pointerover', () => {\n        if (this.selectedIndex !== index) {\n          this.selectedIndex = index;\n          this.updateSelection();\n          this.playSound('power-up-sfx', 0.4);\n        }\n      });\n\n      // Mouse click\n      hitArea.on('pointerdown', () => {\n        this.playSound('punch-sfx', 0.5);\n        action();\n      });\n\n      this.buttons.push({ frame, text: buttonText, action, label, hitArea });\n    });\n\n    // Animate buttons sliding in from the right\n    this.animateButtonsEntrance();\n  }\n\n  private animateButtonsEntrance(): void {\n    // Slide offset for entrance animation\n    const slideOffset = 400;\n\n    // Move all button elements to start position (off-screen right)\n    this.buttons.forEach((button) => {\n      button.frame.x += slideOffset;\n      button.text.x += slideOffset;\n      button.hitArea.x += slideOffset;\n    });\n\n    if (this.buttonContainer) {\n      this.buttonContainer.x += slideOffset;\n    }\n\n    // Animate each button with staggered delay\n    this.buttons.forEach((button, index) => {\n      const delay = index * 100; // Stagger each button\n\n      this.tweens.add({\n        targets: [button.frame, button.text, button.hitArea],\n        x: `-=${slideOffset}`,\n        duration: 600,\n        delay: delay,\n        ease: 'Back.easeOut',\n        easeParams: [1.2],\n      });\n    });\n\n    // Animate the container box\n    if (this.buttonContainer) {\n      this.tweens.add({\n        targets: this.buttonContainer,\n        x: `-=${slideOffset}`,\n        duration: 700,\n        ease: 'Back.easeOut',\n        easeParams: [1.2],\n      });\n    }\n  }\n\n  private drawButtonContainer(): void {\n    this.buttonContainer = this.add.graphics();\n    this.buttonContainer.setDepth(7); // Behind buttons\n    const container = this.buttonContainer;\n\n    // Calculate container bounds (surrounds all 3 buttons with padding)\n    const padding = 50;\n    const padding_y = 30\n    const x = this.BUTTON_X - padding;\n    const y = this.BUTTON_Y_START - this.BUTTON_HEIGHT / 2 - padding_y;\n    const width = this.BUTTON_WIDTH + padding * 2;\n    const height = this.BUTTON_SPACING * 2 + this.BUTTON_HEIGHT + padding_y * 2;\n\n    const borderColor = 0xffffff; // Subtle gray-blue\n    const cornerColor = 0xffffff; // Slightly lighter for corners\n\n    // Draw very subtle main border\n    container.lineStyle(1, borderColor, 0.3);\n    container.strokeRoundedRect(x, y, width, height, 10);\n\n    // Draw tech corner decorations (more prominent)\n    const cornerSize = 25;\n    const cornerOffset = 8;\n    container.lineStyle(2, cornerColor, 0.5);\n\n    // // Top-left corner\n    // container.beginPath();\n    // container.moveTo(x - cornerOffset, y + cornerSize);\n    // container.lineTo(x - cornerOffset, y - cornerOffset);\n    // container.lineTo(x + cornerSize, y - cornerOffset);\n    // container.strokePath();\n\n    // Top-right corner\n    container.beginPath();\n    container.moveTo(x + width - cornerSize, y - cornerOffset);\n    container.lineTo(x + width + cornerOffset, y - cornerOffset);\n    container.lineTo(x + width + cornerOffset, y + cornerSize);\n    container.strokePath();\n\n    // Bottom-left corner\n    container.beginPath();\n    container.moveTo(x - cornerOffset, y + height - cornerSize);\n    container.lineTo(x - cornerOffset, y + height + cornerOffset);\n    container.lineTo(x + cornerSize, y + height + cornerOffset);\n    container.strokePath();\n\n    // // Bottom-right corner\n    // container.beginPath();\n    // container.moveTo(x + width - cornerSize, y + height + cornerOffset);\n    // container.lineTo(x + width + cornerOffset, y + height + cornerOffset);\n    // container.lineTo(x + width + cornerOffset, y + height - cornerSize);\n    // container.strokePath();\n\n    // Add subtle inner glow line at top\n    container.lineStyle(1, 0x94a3b8, 0.15);\n    container.beginPath();\n    container.moveTo(x + 20, y + 2);\n    container.lineTo(x + width - 20, y + 2);\n    container.strokePath();\n  }\n\n  private createButtonParticles(): void {\n    // Get initial button position\n    const y = this.BUTTON_Y_START;\n    const centerX = this.BUTTON_X + this.BUTTON_WIDTH / 2;\n\n    // Create particle emitter that orbits around the selected button\n    this.buttonParticles = this.add.particles(centerX, y, 'particle', {\n      speed: { min: 20, max: 40 },\n      angle: { min: 0, max: 360 },\n      scale: { start: 0.5, end: 0.2 },\n      alpha: { start: 0.8, end: 0 },\n      lifespan: 1500,\n      frequency: 80,\n      quantity: 1,\n      tint: [0xbbf7d0, 0xbae6fd, 0x4ade80], // Light green, light blue, green\n      blendMode: Phaser.BlendModes.ADD,\n      emitZone: {\n        type: 'edge',\n        source: new Phaser.Geom.Rectangle(\n          -this.BUTTON_WIDTH / 2 - 10,\n          -this.BUTTON_HEIGHT / 2 - 10,\n          this.BUTTON_WIDTH + 20,\n          this.BUTTON_HEIGHT + 20\n        ),\n        quantity: 32,\n        yoyo: false,\n      },\n    });\n    this.buttonParticles.setDepth(8);\n\n    // Add glow effect to button particles\n    this.buttonParticles.postFX?.addGlow(0xffffff, 2, 0, false, 0.3, 8);\n  }\n\n  private updateButtonParticles(): void {\n    if (!this.buttonParticles) return;\n\n    // Update particle emitter position to follow selected button\n    const y = this.BUTTON_Y_START + this.selectedIndex * this.BUTTON_SPACING;\n    const centerX = this.BUTTON_X + this.BUTTON_WIDTH / 2;\n\n    this.buttonParticles.setPosition(centerX, y);\n  }\n\n  private drawButtonFrame(\n    graphics: Phaser.GameObjects.Graphics,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    isSelected: boolean\n  ): void {\n    graphics.clear();\n\n    // Lighter/whiter border colors, green glow stays the same\n    const borderColor = isSelected ? 0xe0f2e9 : 0x94a3b8; // Light mint-white when selected, light gray otherwise\n    const fillColor =  0x1e293b;\n    const fillAlpha = 0.1;\n    const borderWidth = isSelected ? 3 : 2;\n    const glowColor = 0x4ade80; // Keep the green glow\n\n    // Draw stronger green glow effect for selected button\n    if (isSelected) {\n      for (let i = 8; i > 0; i--) {\n        graphics.lineStyle(i * 2, glowColor, 0.05);\n        graphics.setDepth(15);\n        graphics.strokeRoundedRect(x - i * 2, y - i * 2, width + i * 4, height + i * 4, 8);\n      }\n    }\n\n    // Draw fill\n    graphics.fillStyle(fillColor, fillAlpha);\n    graphics.fillRoundedRect(x, y, width, height, 8);\n\n    // Draw inner highlight line at top (subtle 3D effect)\n    if (isSelected) {\n      graphics.lineStyle(1, 0xffffff, 0.2);\n      graphics.beginPath();\n      graphics.moveTo(x + 15, y + 2);\n      graphics.lineTo(x + width - 15, y + 2);\n      graphics.strokePath();\n    }\n\n    // Draw main border (lighter/whiter)\n    graphics.lineStyle(borderWidth, borderColor, 1);\n    graphics.strokeRoundedRect(x, y, width, height, 8);\n\n    // Draw tech corner decorations (more pronounced, matching border color)\n    const cornerSize = 15;\n    const cornerOffset = 5;\n    graphics.lineStyle(2, borderColor, isSelected ? 1 : 0.7);\n\n    // Top-left corner\n    graphics.beginPath();\n    graphics.moveTo(x - cornerOffset, y + cornerSize);\n    graphics.lineTo(x - cornerOffset, y - cornerOffset);\n    graphics.lineTo(x + cornerSize, y - cornerOffset);\n    graphics.strokePath();\n\n    // Top-right corner\n    graphics.beginPath();\n    graphics.moveTo(x + width - cornerSize, y - cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y - cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y + cornerSize);\n    graphics.strokePath();\n\n    // Bottom-left corner\n    graphics.beginPath();\n    graphics.moveTo(x - cornerOffset, y + height - cornerSize);\n    graphics.lineTo(x - cornerOffset, y + height + cornerOffset);\n    graphics.lineTo(x + cornerSize, y + height + cornerOffset);\n    graphics.strokePath();\n\n    // Bottom-right corner\n    graphics.beginPath();\n    graphics.moveTo(x + width - cornerSize, y + height + cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y + height + cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y + height - cornerSize);\n    graphics.strokePath();\n\n    // Add small accent line on the left for selected button (keep green)\n    if (isSelected) {\n      graphics.lineStyle(4, glowColor, 0.9);\n      graphics.beginPath();\n      graphics.moveTo(x, y + 15);\n      graphics.lineTo(x, y + height - 15);\n      graphics.strokePath();\n    }\n  }\n\n  private createJuanEntrance(): void {\n    // Create swoosh effect first (behind Juan)\n    this.swooshGraphics = this.add.graphics();\n    this.swooshGraphics.setDepth(4);\n    this.swooshGraphics.setAlpha(0);\n\n    // Juan starts off-screen to the left\n    const startX = -300;\n    const finalX = this.JUAN_FINAL_X; // Position on the left side\n    // Position Juan in the center-left area, vertically centered\n    const y = GAME_HEIGHT / 2 + 50;\n\n    // Use the new menu image - centered origin for better positioning\n    this.juanSprite = this.add.image(startX, y, 'juan-menu');\n    this.juanSprite.setScale(0.55); // Smaller scale to fit fully on screen\n    this.juanSprite.setOrigin(0.5, 0.5); // Center origin for easier positioning\n    this.juanSprite.setDepth(5);\n    this.juanSprite.setAlpha(0);\n    // Original sprite already kicks to the right, no flip needed\n\n    // Draw the swoosh effect (positioned to the right of Juan now)\n    // this.drawSwoosh(finalX + 80, y - 50);\n\n    // Entrance animation: slide in from left + fade in\n    this.tweens.add({\n      targets: [this.juanSprite, this.swooshGraphics],\n      x: `+=${finalX - startX}`,\n      alpha: 1,\n      duration: 800,\n      ease: 'Back.easeOut',\n      easeParams: [1.5],\n      onComplete: () => {\n        // Subtle floating animation\n        this.tweens.add({\n          targets: this.juanSprite,\n          y: y - 10,\n          duration: 2000,\n          yoyo: true,\n          repeat: -1,\n          ease: 'Sine.easeInOut',\n        });\n      },\n    });\n  }\n\n\n  private setupKeyboardNavigation(): void {\n    const keyboard = this.input.keyboard;\n    if (!keyboard) return;\n\n    // Up/Down navigation\n    keyboard.on('keydown-UP', () => {\n      if (!this.canNavigate) return;\n      this.selectedIndex = (this.selectedIndex - 1 + this.buttons.length) % this.buttons.length;\n      this.updateSelection();\n      this.playSound('power-up-sfx', 0.4);\n      this.canNavigate = false;\n      this.time.delayedCall(150, () => {\n        this.canNavigate = true;\n      });\n    });\n\n    keyboard.on('keydown-DOWN', () => {\n      if (!this.canNavigate) return;\n      this.selectedIndex = (this.selectedIndex + 1) % this.buttons.length;\n      this.updateSelection();\n      this.playSound('power-up-sfx', 0.4);\n      this.canNavigate = false;\n      this.time.delayedCall(150, () => {\n        this.canNavigate = true;\n      });\n    });\n\n    // Enter to select\n    keyboard.on('keydown-ENTER', () => {\n      this.playSound('punch-sfx', 0.5);\n      this.buttons[this.selectedIndex].action();\n    });\n  }\n\n  private updateSelection(): void {\n    this.buttons.forEach((button, index) => {\n      const isSelected = index === this.selectedIndex;\n      const y = this.BUTTON_Y_START + index * this.BUTTON_SPACING;\n\n      // Redraw frame with selection state\n      this.drawButtonFrame(\n        button.frame,\n        this.BUTTON_X,\n        y - this.BUTTON_HEIGHT / 2,\n        this.BUTTON_WIDTH,\n        this.BUTTON_HEIGHT,\n        isSelected\n      );\n\n      // Update text color\n      if (isSelected) {\n        button.text.setStroke('#4ade80', 6);\n      } else {\n        // button.text.setColor('#ffffff');\n        button.text.setStroke('#000000', 6);\n      }\n    });\n\n    // Update button particles position\n    this.updateButtonParticles();\n\n    // Update red selection overlay\n    // this.updateSelectionOverlay();\n  }\n\n  private createMuteButton(): void {\n    // Position in bottom-right corner\n    const muteX = GAME_WIDTH - 100;\n    const muteY = GAME_HEIGHT - 40;\n\n    // Set initial text based on mute state\n    const buttonText = this.isMuted ? 'ðŸ”‡' : 'ðŸ”Š';\n\n    this.muteButton = this.add.text(muteX, muteY, buttonText, {\n      fontFamily: 'Arial',\n      fontSize: '32px',\n      color: '#cccccc',\n      stroke: '#000000',\n      strokeThickness: 2,\n    });\n    this.muteButton.setOrigin(0.5);\n    this.muteButton.setDepth(20);\n    this.muteButton.setInteractive({ useHandCursor: true });\n\n    // Hover effect\n    this.muteButton.on('pointerover', () => {\n      this.muteButton?.setScale(1.2);\n    });\n\n    this.muteButton.on('pointerout', () => {\n      this.muteButton?.setScale(1.0);\n    });\n\n    // Click to toggle mute\n    this.muteButton.on('pointerdown', () => {\n      this.toggleMute();\n      this.playSound('punch-sfx', 0.3);\n    });\n  }\n\n  private toggleMute(): void {\n    this.isMuted = !this.isMuted;\n\n    // Store mute state in registry for persistence\n    this.registry.set('musicMuted', this.isMuted);\n\n    if (this.menuMusic) {\n      if (this.isMuted) {\n        (this.menuMusic as Phaser.Sound.WebAudioSound).setVolume(0);\n        this.muteButton?.setText('ðŸ”‡');\n      } else {\n        (this.menuMusic as Phaser.Sound.WebAudioSound).setVolume(0.3);\n        this.muteButton?.setText('ðŸ”Š');\n      }\n    }\n  }\n\n  private startMenuMusic(): void {\n    // Check if music is already playing (to avoid stacking on scene restart)\n    const existingMusic = this.sound.get('menu-music');\n    if (existingMusic && existingMusic.isPlaying) {\n      this.menuMusic = existingMusic;\n      // Apply mute state from registry\n      if (this.isMuted) {\n        (this.menuMusic as Phaser.Sound.WebAudioSound).setVolume(0);\n      } else {\n        (this.menuMusic as Phaser.Sound.WebAudioSound).setVolume(0.3);\n      }\n      return;\n    }\n\n    // Start looping menu music with lower volume\n    this.menuMusic = this.sound.add('menu-music', {\n      volume: this.isMuted ? 0 : 0.3,\n      loop: true,\n    });\n    this.menuMusic.play();\n  }\n\n  private playSound(key: string, volume: number = 0.5): void {\n    this.sound.play(key, { volume });\n  }\n\n  private startGame(): void {\n    console.log('[MenuScene] Starting game...');\n\n    // Fade out music\n    if (this.menuMusic && this.menuMusic.isPlaying) {\n      this.tweens.add({\n        targets: this.menuMusic,\n        volume: 0,\n        duration: 300,\n        onComplete: () => {\n          this.menuMusic?.stop();\n        },\n      });\n    }\n\n    // Camera fade out\n    this.cameras.main.fadeOut(400, 0, 0, 0);\n\n    this.cameras.main.once('camerafadeoutcomplete', () => {\n      this.scene.start('Versus');\n    });\n  }\n}\n","/**\n * Player Entity\n * ==============\n * Represents Juan - the playable character.\n * Uses composition pattern to wrap a Phaser sprite.\n */\n\nimport Phaser from 'phaser';\nimport { InputManager } from '../systems/InputManager.ts';\nimport { HealthBar } from '../ui/HealthBar.ts';\n\n/** Player physics and movement configuration */\nconst CONFIG = {\n  MOVE_SPEED: 300,\n  ACCELERATION: 1500,\n  DRAG: 1000,\n  JUMP_VELOCITY: -450,\n  MAX_JUMPS: 2, // Allow double jump\n  JUMP_BUFFER_TIME: 150, // ms to buffer jump input (allows pressing jump slightly early)\n  // Standardized sprite dimensions: 200x400 per frame\n  FRAME_WIDTH: 200,\n  FRAME_HEIGHT: 400,\n  // Scale to fit the game (400 * 0.65 = 260px tall character)\n  SCALE: 0.65,\n  // Physics body size (in texture coordinates)\n  BODY_WIDTH: 80,\n  BODY_HEIGHT: 200, // Reduced from 280 to give head clearance\n  // Character positioning within frame (in texture coordinates)\n  // Empty space above the character's head\n  CHAR_TOP_PADDING: 30,\n  // Empty space below the character's feet (30px from bottom = feet at 370px)\n  CHAR_BOTTOM_PADDING: 30,\n  // Health system\n  MAX_HEALTH: 100,\n  INVINCIBILITY_DURATION: 500, // ms\n  KNOCKBACK_FORCE: 250, // pixels/second\n};\n\n/** Damage values for different attacks */\nconst DAMAGE = {\n  PUNCH: 10,\n  UPPERCUT: 20, // Combo punch\n  AERIAL_PUNCH: 15,\n};\n\n/** Player state for animation system */\nexport enum PlayerState {\n  IDLE,\n  RUNNING,\n  JUMPING,\n  FALLING,\n  ATTACKING,\n  HURT,\n  DEAD,\n  DODGING,\n}\n\nexport class Player {\n  private scene: Phaser.Scene;\n  private sprite: Phaser.Physics.Arcade.Sprite;\n  private inputManager: InputManager;\n  private jumpsRemaining: number = CONFIG.MAX_JUMPS;\n  private currentState: PlayerState = PlayerState.IDLE;\n  private facingRight: boolean = true;\n\n  // Combo system timing\n  private readonly COMBO_WINDOW: number = 800;     // ms to chain combo\n  private readonly COMBO_MIN_DELAY: number = 250;  // ms before combo can trigger (let first anim play)\n\n  // Punch combo system\n  private comboCount: number = 0;\n  private comboTimer: number = 0;\n  private comboDelayTimer: number = 0;\n\n  // Input buffer - queue next attack during current animation\n  private bufferedAttack: 'punch' | 'uppercut' | 'aerial-punch' | null = null;\n\n  // Jump buffer - allows pressing jump slightly before landing\n  private jumpBufferTimer: number = 0;\n\n  // Health system\n  private maxHealth: number = CONFIG.MAX_HEALTH;\n  private currentHealth: number = CONFIG.MAX_HEALTH;\n  private isInvincible: boolean = false;\n  private invincibilityTimer: number = 0;\n  private healthBar: HealthBar | null = null;\n\n  // Attack tracking for hitbox generation\n  private currentAttackType: 'punch' | 'uppercut' | 'aerial-punch' | null = null;\n\n  // Counter-dodge system - callbacks for enemy warning checks\n  private isAnyEnemyShowingWarning: (() => boolean) | null = null;\n  private getTimeUntilEnemyAttack: (() => number) | null = null;\n  private counterDodgeQueued: boolean = false; // True if player pressed U during warning\n\n  // All animations now use standardized 200x400 frames - no per-animation config needed!\n\n  constructor(scene: Phaser.Scene, x: number, y: number, inputManager: InputManager) {\n    this.scene = scene;\n    this.inputManager = inputManager;\n\n    // Create animations\n    this.createAnimations();\n\n    // Create the physics sprite\n    // Set origin at character's feet position (not frame bottom)\n    this.sprite = scene.physics.add.sprite(x, y, 'juan-idle');\n    const originY = (CONFIG.FRAME_HEIGHT - CONFIG.CHAR_BOTTOM_PADDING) / CONFIG.FRAME_HEIGHT;\n    this.sprite.setOrigin(0.5, originY);\n    this.sprite.setScale(CONFIG.SCALE);\n\n    // Configure physics body\n    this.setupPhysicsBody();\n\n    // Start with idle animation\n    this.sprite.play('juan-idle');\n  }\n\n  private createAnimations(): void {\n    // Idle animation - 6 frames (row 1 of 6x3 grid), looping\n    this.scene.anims.create({\n      key: 'juan-idle',\n      frames: this.scene.anims.generateFrameNumbers('juan-idle', { start: 0, end: 5 }),\n      frameRate: 8,\n      repeat: -1, // Loop forever\n    });\n\n    // Run animation - 12 frames (rows 1-2 of 6x3 grid), looping\n    this.scene.anims.create({\n      key: 'running-animation',\n      frames: this.scene.anims.generateFrameNumbers('running-animation', { start: 0, end: 7 }),\n      frameRate: 24,\n      repeat: -1, // Loop forever\n    });\n\n    // Jump animation - 6 frames (single row), plays once\n    this.scene.anims.create({\n      key: 'juan-jump',\n      frames: this.scene.anims.generateFrameNumbers('juan-jump', { start: 0, end: 3 }),\n      frameRate: 10,\n      repeat: 0, // Play once and hold last frame\n    });\n\n    // Punch animation - 6 standard frames (200px each)\n    // Sequence: guard -> wind-up -> jab -> impact -> retract -> recovery\n    this.scene.anims.create({\n      key: 'juan-punch',\n      frames: [\n        { key: 'juan-punch', frame: 0 },      // guard stance\n        { key: 'juan-punch', frame: 1 },      // wind-up\n        { key: 'juan-punch', frame: 2 },      // jab thrust\n        { key: 'juan-punch', frame: 3 },      // impact\n        { key: 'juan-punch', frame: 4 },      // retract\n        { key: 'juan-punch', frame: 5 },      // recovery\n      ],\n      frameRate: 12,\n      repeat: 0,\n      // yoyo: true, // Play forward then backward\n    });\n\n    // Uppercut animation - 5 frames, plays forward then backward\n    this.scene.anims.create({\n      key: 'juan-uppercut',\n      frames: this.scene.anims.generateFrameNumbers('juan-uppercut', { start: 0, end: 4 }),\n      frameRate: 14,\n      repeat: 0,\n      yoyo: true, // Play forward then backward\n    });\n\n    // Aerial punch animation - uses custom wide frames (frames 1+2 and 3+4 combined = 400px each)\n    // Layout: frame0 (200px) | frames1+2 (400px) | frames3+4 (400px) | frame5 (200px)\n    // Sequence: stance -> windup (wide) -> punch (wide) -> recovery\n    this.scene.anims.create({\n      key: 'juan-aerial-punch',\n      frames: [\n        { key: 'juan-aerial-punch', frame: 0 },         // frame 0: stance (200px)\n        { key: 'juan-aerial-punch', frame: 'windup' },  // frames 1+2 combined (400px wide)\n        { key: 'juan-aerial-punch', frame: 'punch' },   // frames 3+4 combined (400px wide)\n        { key: 'juan-aerial-punch', frame: 5 },         // frame 5: recovery (200px)\n      ],\n      frameRate: 12,\n      repeat: 0,\n    });\n\n    // Getting punched animation - 5 frames, hurt/damage reaction\n    // Sequence: standing -> brace -> impact -> recoil -> recovery\n    this.scene.anims.create({\n      key: 'juan-getting-punched',\n      frames: this.scene.anims.generateFrameNumbers('juan-getting-punched', { start: 0, end: 4 }),\n      frameRate: 18,\n      repeat: 0,\n      yoyo: true,\n    });\n\n    // Getting punched in stomach animation - 4 frames, gut punch reaction\n    // Sequence: standing -> brace -> doubled over -> recovery\n    this.scene.anims.create({\n      key: 'juan-getting-punched-stomach',\n      frames: this.scene.anims.generateFrameNumbers('juan-getting-punched-stomach', { start: 0, end: 4 }),\n      frameRate: 18,\n      repeat: 0,\n      yoyo: true,\n    });\n\n    // Dodge animation - 4 frames, evasion sequence\n    // Sequence: react -> lean back -> dodge -> full dodge\n    this.scene.anims.create({\n      key: 'juan-dodge',\n      frames: this.scene.anims.generateFrameNumbers('juan-dodge', { start: 0, end: 3 }),\n      frameRate: 14,\n      repeat: 0,\n      yoyo: true, // Play forward then backward (dodge and return)\n    });\n\n    // Matrix dodge animation - uses custom wide frames for deep lean/crouch poses\n    // Sequence: stance -> lean -> lean more -> lean deep (wide) -> crouch_1 (wide) -> crouch_2 (wide) -> crouch_3 (wide)\n    this.scene.anims.create({\n      key: 'juan-matrix-dodge',\n      frames: [\n        { key: 'juan-matrix-dodge', frame: 0 },           // stance\n        { key: 'juan-matrix-dodge', frame: 1 },           // lean start\n        { key: 'juan-matrix-dodge', frame: 2 },           // lean more\n        { key: 'juan-matrix-dodge', frame: 'lean_deep' }, // frames 4&5 combined (400px)\n        { key: 'juan-matrix-dodge', frame: 'crouch_1' },  // frames 6&7 combined (400px)\n ],\n      frameRate: 14,\n      repeat: 0,\n      yoyo: true, // Play forward then backward (dodge and return)\n    });\n\n    // Kipup dodge animation - acrobatic flip dodge\n    // Layout: 1200x800, 6 columns x 2 rows = 12 slots, ~10 frames used\n    // Sequence: stance -> kick up -> roll -> recovery -> back to stance\n    this.scene.anims.create({\n      key: 'juan-kipup',\n      frames: this.scene.anims.generateFrameNumbers('juan-kipup', { start: 0, end: 10 }),\n      frameRate: 16,\n      repeat: 0,\n    });\n  }\n\n  private setupPhysicsBody(): void {\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n\n    // Set physics body size (in texture coordinates, scaled automatically)\n    body.setSize(CONFIG.BODY_WIDTH, CONFIG.BODY_HEIGHT);\n\n    // Character is centered in frame with padding above and below\n    // Center body horizontally\n    const offsetX = (CONFIG.FRAME_WIDTH - CONFIG.BODY_WIDTH) / 2;\n    // Position body to align with where character actually is in the frame\n    // Body bottom should be at: FRAME_HEIGHT - CHAR_BOTTOM_PADDING\n    const offsetY = CONFIG.FRAME_HEIGHT - CONFIG.CHAR_BOTTOM_PADDING - CONFIG.BODY_HEIGHT;\n    body.setOffset(offsetX, offsetY);\n\n    // Prevent player from leaving the game world horizontally\n    body.setCollideWorldBounds(true);\n    body.setMaxVelocity(CONFIG.MOVE_SPEED, 800);\n    body.setDrag(CONFIG.DRAG, 0);\n  }\n\n  // With standardized 200x400 frames, no per-animation adjustments needed!\n\n\n  update(): void {\n    if (!this.scene.registry.get('matchStarted')) return;\n\n    const delta = this.scene.game.loop.delta;\n\n    // Update punch combo timers\n    if (this.comboTimer > 0) {\n      this.comboTimer -= delta;\n      if (this.comboTimer <= 0) {\n        this.comboCount = 0; // Reset combo if window expired\n      }\n    }\n    if (this.comboDelayTimer > 0) {\n      this.comboDelayTimer -= delta;\n    }\n\n    // Update invincibility timer\n    if (this.invincibilityTimer > 0) {\n      this.invincibilityTimer -= delta;\n      if (this.invincibilityTimer <= 0) {\n        this.isInvincible = false;\n      }\n    }\n\n    // Debug: Press P to trigger hurt animation (temporary, for testing without enemies)\n    this.handleDebugHurt();\n\n    this.handleCounterDodge();\n    this.handleDodge();\n    this.handleMatrixDodge();\n    this.handleAttack();\n    this.handleMovement();\n    this.handleJump();\n    this.updateState();\n    this.updateFacing();\n  }\n\n  /** Debug method to trigger hurt animations with P/O keys (temporary, for testing) */\n  private handleDebugHurt(): void {\n    if (this.inputManager.isDebugHurtPressed()) {\n      this.triggerHurt();\n    }\n    if (this.inputManager.isDebugHurtStomachPressed()) {\n      this.triggerHurtStomach();\n    }\n  }\n\n  /** Trigger the hurt/getting punched animation (face) */\n  public triggerHurt(): void {\n    // Don't interrupt if already hurt\n    if (this.currentState === PlayerState.HURT) {\n      return;\n    }\n\n    this.currentState = PlayerState.HURT;\n    this.sprite.play('juan-getting-punched');\n\n    // Return to idle after animation completes\n    this.sprite.once('animationcomplete', () => {\n      this.currentState = PlayerState.IDLE;\n      this.sprite.play('juan-idle');\n    });\n  }\n\n  /** Trigger the stomach hurt/gut punch animation */\n  public triggerHurtStomach(): void {\n    // Don't interrupt if already hurt\n    if (this.currentState === PlayerState.HURT) {\n      return;\n    }\n\n    this.currentState = PlayerState.HURT;\n    this.sprite.play('juan-getting-punched-stomach');\n\n    // Return to idle after animation completes\n    this.sprite.once('animationcomplete', () => {\n      this.currentState = PlayerState.IDLE;\n      this.sprite.play('juan-idle');\n    });\n  }\n\n  /** Handle dodge input (I key) */\n  private handleDodge(): void {\n    // Don't allow dodge while already dodging, attacking, or hurt\n    if (this.currentState === PlayerState.DODGING ||\n      this.currentState === PlayerState.ATTACKING ||\n      this.currentState === PlayerState.HURT) {\n      return;\n    }\n\n    if (this.inputManager.isDodgePressed()) {\n      this.performDodge();\n    }\n  }\n\n  /** Perform the dodge animation */\n  private performDodge(): void {\n    this.currentState = PlayerState.DODGING;\n    this.sprite.play('juan-dodge');\n\n    // Return to idle after animation completes\n    this.sprite.once('animationcomplete', () => {\n      this.currentState = PlayerState.IDLE;\n      this.sprite.play('juan-idle');\n    });\n  }\n\n  /** Handle matrix dodge input (L key) */\n  private handleMatrixDodge(): void {\n    // Don't allow matrix dodge while already dodging, attacking, or hurt\n    if (this.currentState === PlayerState.DODGING ||\n      this.currentState === PlayerState.ATTACKING ||\n      this.currentState === PlayerState.HURT) {\n      return;\n    }\n\n    if (this.inputManager.isMatrixDodgePressed()) {\n      this.performMatrixDodge();\n    }\n  }\n\n  /** Perform the matrix-style dodge animation */\n  private performMatrixDodge(): void {\n    this.currentState = PlayerState.DODGING;\n    this.sprite.play('juan-matrix-dodge');\n\n    // Return to idle after animation completes\n    this.sprite.once('animationcomplete', () => {\n      this.currentState = PlayerState.IDLE;\n      this.sprite.play('juan-idle');\n    });\n  }\n\n  /**\n   * Set the callback functions for enemy warning system\n   * This is called by GameScene after creating the player\n   * @param warningChecker - Returns true if any enemy is showing attack warning\n   * @param timeUntilAttack - Returns ms until the next enemy attack executes\n   */\n  public setEnemyWarningChecker(warningChecker: () => boolean, timeUntilAttack: () => number): void {\n    this.isAnyEnemyShowingWarning = warningChecker;\n    this.getTimeUntilEnemyAttack = timeUntilAttack;\n  }\n\n  /**\n   * Handle counter-dodge input (U key)\n   * Counter-dodge only works during enemy attack warning window (500ms)\n   * If pressed during warning, dodge animation is delayed to sync with enemy attack\n   */\n  private handleCounterDodge(): void {\n    // Don't allow counter-dodge while already dodging, attacking, hurt, or already queued\n    if (this.currentState === PlayerState.DODGING ||\n      this.currentState === PlayerState.ATTACKING ||\n      this.currentState === PlayerState.HURT ||\n      this.counterDodgeQueued) {\n      return;\n    }\n\n    if (this.inputManager.isCounterDodgePressed()) {\n      // Check if any enemy is showing attack warning\n      const enemyIsAttacking = this.isAnyEnemyShowingWarning?.() ?? false;\n      \n      if (enemyIsAttacking) {\n        // Successful counter-dodge! Queue the dodge to sync with enemy attack\n        this.queueCounterDodge();\n      } else {\n        // Missed timing - play dodge immediately but no invincibility\n        this.performCounterDodge(false, 0);\n      }\n    }\n  }\n\n  /**\n   * Queue a counter-dodge to execute when the enemy attack happens\n   * The dodge animation will be delayed to sync with the incoming attack\n   */\n  private queueCounterDodge(): void {\n    // Get the time until enemy attack executes\n    const delayMs = this.getTimeUntilEnemyAttack?.() ?? 0;\n    \n    // Mark as queued so we don't queue multiple times\n    this.counterDodgeQueued = true;\n    \n    // Grant invincibility immediately to protect during the wait\n    // Duration covers: wait time + dodge animation time\n    this.isInvincible = true;\n    this.invincibilityTimer = delayMs + 600;\n    \n    if (delayMs > 0) {\n      // Delay the dodge animation to sync with enemy attack\n      this.scene.time.delayedCall(delayMs, () => {\n        this.performCounterDodge(true, 0);\n      });\n    } else {\n      // No delay needed, execute immediately\n      this.performCounterDodge(true, 0);\n    }\n  }\n\n  /**\n   * Perform the counter-dodge animation\n   * @param successful - If true, player timed the dodge correctly during warning\n   * @param _delay - Unused, kept for API consistency\n   */\n  private performCounterDodge(successful: boolean, _delay: number): void {\n    this.currentState = PlayerState.DODGING;\n    this.counterDodgeQueued = false; // Clear the queue flag\n    \n    // Randomly choose between the three dodge animations\n    const dodgeAnimations = ['juan-dodge', 'juan-matrix-dodge', 'juan-kipup'];\n    const randomIndex = Math.floor(Math.random() * dodgeAnimations.length);\n    const animKey = dodgeAnimations[randomIndex];\n    \n    this.sprite.play(animKey);\n\n    if (successful) {\n      // Invincibility was already granted in queueCounterDodge\n      // Just add a subtle scale pulse for visual feedback\n      this.scene.tweens.add({\n        targets: this.sprite,\n        scaleX: CONFIG.SCALE * 1.05,\n        scaleY: CONFIG.SCALE * 1.05,\n        duration: 100,\n        yoyo: true,\n        ease: 'Sine.easeInOut',\n      });\n    }\n\n    // Return to idle after animation completes\n    this.sprite.once('animationcomplete', () => {\n      this.currentState = PlayerState.IDLE;\n      this.sprite.play('juan-idle');\n    });\n  }\n\n  private handleAttack(): void {\n    // Don't allow attacks while hurt\n    if (this.currentState === PlayerState.HURT) {\n      return;\n    }\n\n    // Cache key states (JustDown only returns true once per press)\n    const punchPressed = this.inputManager.isPunchPressed();\n    const uppercutPressed = this.inputManager.isUppercutPressed();\n    const isAttacking = this.currentState === PlayerState.ATTACKING;\n    const isAirborne = !this.isOnGround();\n\n    // Aerial punch - only C (punch) while in the air triggers aerial punch\n    if (isAirborne && !isAttacking && punchPressed) {\n      this.performAerialPunch();\n      return;\n    }\n\n    // Allow combo continuation even while attacking (but only after min delay)\n    // C key combo: second C during punch = uppercut\n    if (punchPressed && this.comboCount === 1 && this.comboDelayTimer <= 0) {\n      this.bufferedAttack = null; // Clear buffer, combo takes priority\n      this.performUppercut();\n      this.comboCount = 0;\n      this.comboTimer = 0;\n      return;\n    }\n\n    // Buffer inputs while attacking (queue next attack)\n    if (isAttacking) {\n      if (punchPressed) this.bufferedAttack = isAirborne ? 'aerial-punch' : 'punch';\n      else if (uppercutPressed) this.bufferedAttack = 'uppercut';\n      return;\n    }\n\n    // V key = uppercut (direct)\n    if (uppercutPressed) {\n      this.performUppercut();\n      return;\n    }\n\n    // C key = punch (first press starts combo)\n    if (punchPressed) {\n      this.performPunch();\n      return;\n    }\n\n    // Kick/sidekick removed\n  }\n\n  private onAttackComplete(): void {\n    // Check for buffered attack\n    if (this.bufferedAttack) {\n      const attack = this.bufferedAttack;\n      this.bufferedAttack = null;\n\n      switch (attack) {\n        case 'punch':\n          this.performPunch();\n          break;\n        case 'uppercut':\n          this.performUppercut();\n          break;\n        case 'aerial-punch':\n          this.performAerialPunch();\n          break;\n      }\n    } else {\n      this.currentState = PlayerState.IDLE;\n      this.sprite.play('juan-idle');\n    }\n  }\n\n  private performPunch(): void {\n    this.currentState = PlayerState.ATTACKING;\n    this.currentAttackType = 'punch';\n    this.sprite.play('juan-punch');\n    this.scene.sound.play('punch-sfx', { volume: 0.5 });\n    this.comboCount = 1;\n    this.comboTimer = this.COMBO_WINDOW;\n    this.comboDelayTimer = this.COMBO_MIN_DELAY;\n    this.sprite.once('animationcomplete', () => {\n      this.currentAttackType = null;\n      this.onAttackComplete();\n    });\n  }\n\n  private performUppercut(): void {\n    this.currentState = PlayerState.ATTACKING;\n    this.currentAttackType = 'uppercut';\n    this.sprite.play('juan-uppercut');\n    this.scene.sound.play('punch-sfx', { volume: 0.6 });\n    this.sprite.once('animationcomplete', () => {\n      this.currentAttackType = null;\n      this.onAttackComplete();\n    });\n  }\n\n  private performAerialPunch(): void {\n    this.currentState = PlayerState.ATTACKING;\n    this.currentAttackType = 'aerial-punch';\n    this.sprite.play('juan-aerial-punch');\n    this.scene.sound.play('punch-sfx', { volume: 0.6 });\n    this.sprite.once('animationcomplete', () => {\n      this.currentAttackType = null;\n      this.onAttackComplete();\n    });\n  }\n\n  private handleMovement(): void {\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n\n    // Don't move while attacking, hurt, or dodging (keeps player planted during animations)\n    if (this.currentState === PlayerState.ATTACKING ||\n      this.currentState === PlayerState.HURT ||\n      this.currentState === PlayerState.DODGING) {\n      body.setAccelerationX(0);\n      return;\n    }\n\n    if (this.inputManager.isMovingLeft()) {\n      body.setAccelerationX(-CONFIG.ACCELERATION);\n      this.facingRight = false;\n    } else if (this.inputManager.isMovingRight()) {\n      body.setAccelerationX(CONFIG.ACCELERATION);\n      this.facingRight = true;\n    } else {\n      body.setAccelerationX(0);\n    }\n  }\n\n  private handleJump(): void {\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n    const delta = this.scene.game.loop.delta;\n\n    // Update jump buffer timer\n    if (this.jumpBufferTimer > 0) {\n      this.jumpBufferTimer -= delta;\n    }\n\n    // Buffer jump input when pressed\n    if (this.inputManager.isJumpPressed()) {\n      this.jumpBufferTimer = CONFIG.JUMP_BUFFER_TIME;\n    }\n\n    // Reset jumps when grounded\n    if (body.blocked.down) {\n      this.jumpsRemaining = CONFIG.MAX_JUMPS;\n    }\n\n    // Execute jump if buffer is active and we have jumps remaining\n    if (this.jumpBufferTimer > 0 && this.jumpsRemaining > 0) {\n      body.setVelocityY(CONFIG.JUMP_VELOCITY);\n      this.jumpsRemaining--;\n      this.jumpBufferTimer = 0; // Consume the buffer\n    }\n  }\n\n  private updateState(): void {\n    // Don't change state while attacking, hurt, or dodging\n    if (this.currentState === PlayerState.ATTACKING ||\n      this.currentState === PlayerState.HURT ||\n      this.currentState === PlayerState.DODGING) {\n      return;\n    }\n\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n    const previousState = this.currentState;\n\n    if (!body.blocked.down) {\n      this.currentState = body.velocity.y < 0 ? PlayerState.JUMPING : PlayerState.FALLING;\n    } else {\n      this.currentState = Math.abs(body.velocity.x) > 10 ? PlayerState.RUNNING : PlayerState.IDLE;\n    }\n\n    // Play animation when state changes\n    if (this.currentState !== previousState) {\n      this.playAnimationForState();\n    }\n  }\n\n  private playAnimationForState(): void {\n    switch (this.currentState) {\n      case PlayerState.IDLE:\n        if (this.sprite.anims.currentAnim?.key !== 'juan-idle') {\n          this.sprite.play('juan-idle');\n        }\n        break;\n      case PlayerState.RUNNING:\n        if (this.sprite.anims.currentAnim?.key !== 'running-animation') {\n          this.sprite.play('running-animation');\n        }\n        break;\n      case PlayerState.JUMPING:\n      case PlayerState.FALLING:\n        // Use jump animation for air states\n        if (this.sprite.anims.currentAnim?.key !== 'juan-jump') {\n          this.sprite.play('juan-jump');\n        }\n        break;\n      case PlayerState.ATTACKING:\n        // Keep current attack animation playing\n        break;\n    }\n  }\n\n  private updateFacing(): void {\n    const shouldFlip = !this.facingRight;\n    if (this.sprite.flipX !== shouldFlip) {\n      this.sprite.setFlipX(shouldFlip);\n    }\n  }\n\n  /** Get the underlying Phaser sprite for physics/camera */\n  getSprite(): Phaser.Physics.Arcade.Sprite {\n    return this.sprite;\n  }\n\n  getState(): PlayerState {\n    return this.currentState;\n  }\n\n  isOnGround(): boolean {\n    return (this.sprite.body as Phaser.Physics.Arcade.Body).blocked.down;\n  }\n\n  /**\n   * Take damage from an attack\n   */\n  takeDamage(amount: number, attackerX: number): void {\n    // Don't take damage if invincible or dead\n    if (this.isInvincible || this.currentHealth <= 0) {\n      return;\n    }\n\n    this.currentHealth = Math.max(0, this.currentHealth - amount);\n\n    // Update health bar\n    if (this.healthBar) {\n      this.healthBar.updateHealth(this.currentHealth);\n    }\n\n    // Apply knockback\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n    const knockbackDirection = this.sprite.x < attackerX ? -1 : 1;\n    body.setVelocityX(knockbackDirection * CONFIG.KNOCKBACK_FORCE);\n\n    // Start invincibility\n    this.isInvincible = true;\n    this.invincibilityTimer = CONFIG.INVINCIBILITY_DURATION;\n\n    // Play hurt animation\n    this.triggerHurt();\n\n    // Check if dead\n    if (this.currentHealth <= 0) {\n      this.currentState = PlayerState.DEAD;\n      // Freeze in place\n      body.setVelocity(0, 0);\n      body.setAcceleration(0, 0);\n    }\n  }\n\n  /**\n   * Get the current attack hitbox bounds if attacking\n   * Returns null if not attacking or not in hit frame\n   */\n  getAttackHitbox(): Phaser.Geom.Rectangle | null {\n    if (this.currentState !== PlayerState.ATTACKING || !this.currentAttackType) {\n      return null;\n    }\n\n    const anim = this.sprite.anims.currentAnim;\n    if (!anim) return null;\n\n    // Get current frame from sprite's animation manager\n    // Use type assertion as Phaser types may be incomplete\n    const animsManager = this.sprite.anims as any;\n    const currentFrame = animsManager.currentFrame;\n    if (!currentFrame) return null;\n\n    // Determine hitbox based on attack type\n    let hitboxWidth = 80;\n    let hitboxHeight = 60;\n    let offsetX = this.facingRight ? 50 : -50;\n    let offsetY = -30; // Slightly above center\n\n    // Adjust hitbox for different attacks\n    switch (this.currentAttackType) {\n      case 'punch':\n        // Punch hitbox - check if we're on the impact frame (index 3 in the animation)\n        if (anim.key === 'juan-punch' && currentFrame.index >= 2 && currentFrame.index <= 3) {\n          hitboxWidth = 100;\n          offsetX = this.facingRight ? 60 : -60;\n        } else {\n          return null; // Not in hit frame yet\n        }\n        break;\n      case 'uppercut':\n        // Uppercut hitbox - upward strike\n        if (anim.key === 'juan-uppercut' && currentFrame.index >= 1 && currentFrame.index <= 3) {\n          hitboxWidth = 70;\n          hitboxHeight = 80;\n          offsetX = this.facingRight ? 40 : -40;\n          offsetY = -50; // Higher up\n        } else {\n          return null;\n        }\n        break;\n      case 'aerial-punch':\n        // Aerial punch hitbox\n        if (anim.key === 'juan-aerial-punch' &&\n          (currentFrame.frame.name === 'windup' || currentFrame.frame.name === 'punch')) {\n          hitboxWidth = 100;\n          offsetX = this.facingRight ? 60 : -60;\n        } else {\n          return null;\n        }\n        break;\n    }\n\n    // Create hitbox rectangle\n    const hitboxX = this.sprite.x + offsetX - hitboxWidth / 2;\n    const hitboxY = this.sprite.y + offsetY - hitboxHeight / 2;\n\n    return new Phaser.Geom.Rectangle(hitboxX, hitboxY, hitboxWidth, hitboxHeight);\n  }\n\n  /**\n   * Get damage value for current attack\n   */\n  getAttackDamage(): number {\n    if (!this.currentAttackType) return 0;\n\n    switch (this.currentAttackType) {\n      case 'punch':\n        return DAMAGE.PUNCH;\n      case 'uppercut':\n        return DAMAGE.UPPERCUT;\n      case 'aerial-punch':\n        return DAMAGE.AERIAL_PUNCH;\n      default:\n        return 0;\n    }\n  }\n\n  /**\n   * Get current attack type (for determining enemy reaction)\n   */\n  getAttackType(): string | null {\n    return this.currentAttackType;\n  }\n\n  /**\n   * Set health bar reference\n   */\n  setHealthBar(healthBar: HealthBar): void {\n    this.healthBar = healthBar;\n  }\n\n  /**\n   * Get current health\n   */\n  getCurrentHealth(): number {\n    return this.currentHealth;\n  }\n\n  /**\n   * Get max health\n   */\n  getMaxHealth(): number {\n    return this.maxHealth;\n  }\n\n  /**\n   * Check if player is dead\n   */\n  isDead(): boolean {\n    return this.currentHealth <= 0;\n  }\n\n  /**\n   * Check if player is invincible\n   */\n  getIsInvincible(): boolean {\n    return this.isInvincible;\n  }\n}\n","/**\n * Enemy Entity\n * ==============\n * Represents a basic enemy character.\n * Uses composition pattern to wrap a Phaser sprite.\n */\n\nimport Phaser from 'phaser';\nimport { InputManager } from '../systems/InputManager';\nimport { HealthBar } from '../ui/HealthBar';\n\n/** Enemy configuration */\nconst CONFIG = {\n  // Frame dimensions (must match PreloadScene sprite sheet config)\n  FRAME_WIDTH: 200,\n  FRAME_HEIGHT: 400,\n  // Scale to fit the game\n  SCALE: 0.8,\n  // Physics body size (in texture coordinates)\n  BODY_WIDTH: 100,\n  BODY_HEIGHT: 220,\n  // Movement settings\n  MOVE_SPEED: 250,\n  ACCELERATION: 1200,\n  DRAG: 800,\n  JUMP_VELOCITY: -650,\n  // Health system\n  MAX_HEALTH: 300,\n  INVINCIBILITY_DURATION: 800, // ms (must be longer than longest yoyo attack animation)\n  KNOCKBACK_FORCE: 250, // pixels/second\n  // Attack warning system\n  ATTACK_WARNING_DURATION: 500, // ms before attack executes\n};\n\n/** Enemy state for animation system */\nexport enum EnemyState {\n  IDLE,\n  RUNNING,\n  JUMPING,\n  FALLING,\n  ATTACKING,\n  HURT,\n}\n\nexport class Enemy {\n  private scene: Phaser.Scene;\n  private sprite: Phaser.Physics.Arcade.Sprite;\n  private inputManager: InputManager;\n  private currentState: EnemyState = EnemyState.IDLE;\n  private facingRight: boolean = false; // Start facing left (toward player)\n\n  // Health system\n  private maxHealth: number = CONFIG.MAX_HEALTH;\n  private currentHealth: number = CONFIG.MAX_HEALTH;\n  private isInvincible: boolean = false;\n  private invincibilityTimer: number = 0;\n  private healthBar: HealthBar | null = null;\n\n  // Attack system\n  private currentAttackType: 'punch' | 'sidekick' | null = null;\n\n  // Attack warning system\n  private warningContainer: Phaser.GameObjects.Container | null = null;\n  private warningGraphics: Phaser.GameObjects.Graphics | null = null;\n  private warningText: Phaser.GameObjects.Text | null = null;\n  private pendingAttack: 'punch' | 'sidekick' | null = null;\n  private warningTween: Phaser.Tweens.Tween | null = null;\n  private attackExecuteTime: number = 0; // When the attack will execute (scene time)\n\n  // AI control system - allows programmatic control alongside keyboard\n  private aiMovementDirection: -1 | 0 | 1 = 0; // -1 = left, 0 = none, 1 = right\n  private aiJumpRequested: boolean = false;\n  \n  // Distance-based movement tracking\n  private targetX: number | null = null; // Target X position for moveLeftBy/moveRightBy\n\n  constructor(scene: Phaser.Scene, x: number, y: number, inputManager: InputManager) {\n    this.scene = scene;\n    this.inputManager = inputManager;\n\n    // Create animations\n    this.createAnimations();\n\n    // Create the physics sprite\n    this.sprite = scene.physics.add.sprite(x, y, 'enemy-idle');\n    this.sprite.setOrigin(0.5, 1); // Origin at feet\n    this.sprite.setScale(CONFIG.SCALE);\n\n    // Configure physics body\n    this.setupPhysicsBody();\n\n    // Create attack warning indicator\n    this.createWarningIndicator();\n\n    // Start with idle animation\n    this.sprite.play('enemy-idle');\n  }\n\n  /**\n   * Create the visual warning indicator for attacks\n   */\n  private createWarningIndicator(): void {\n    // Create container to hold warning elements\n    this.warningContainer = this.scene.add.container(this.sprite.x, this.sprite.y - 180);\n    this.warningContainer.setDepth(100);\n    this.warningContainer.setVisible(false);\n\n    // Create glowing background circle\n    this.warningGraphics = this.scene.add.graphics();\n    \n    // Draw outer glow (multiple layers for soft glow effect)\n    this.warningGraphics.fillStyle(0xff0000, 0.15);\n    this.warningGraphics.fillCircle(0, 0, 35);\n    this.warningGraphics.fillStyle(0xff0000, 0.25);\n    this.warningGraphics.fillCircle(0, 0, 28);\n    this.warningGraphics.fillStyle(0xff3300, 0.4);\n    this.warningGraphics.fillCircle(0, 0, 22);\n    this.warningGraphics.fillStyle(0xff5500, 0.6);\n    this.warningGraphics.fillCircle(0, 0, 16);\n    \n    // Draw inner solid circle\n    this.warningGraphics.fillStyle(0xff0000, 1);\n    this.warningGraphics.fillCircle(0, 0, 12);\n    \n    // Add exclamation mark\n    this.warningText = this.scene.add.text(0, 0, '!', {\n      fontFamily: 'Quantico, Arial',\n      fontSize: '24px',\n      fontStyle: 'bold',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 2,\n    });\n    this.warningText.setOrigin(0.5, 0.5);\n\n    // Add elements to container\n    this.warningContainer.add([this.warningGraphics, this.warningText]);\n  }\n\n  private createAnimations(): void {\n    // Only create animations if they don't already exist\n    if (!this.scene.anims.exists('enemy-idle')) {\n      // Idle animation - 3 frames, looping\n      this.scene.anims.create({\n        key: 'enemy-idle',\n        frames: this.scene.anims.generateFrameNumbers('enemy-idle', { start: 0, end: 2 }),\n        frameRate: 6,\n        repeat: -1, // Loop forever\n      });\n    }\n\n    if (!this.scene.anims.exists('enemy-running')) {\n      // Running animation - 8 frames, looping\n      this.scene.anims.create({\n        key: 'enemy-running',\n        frames: this.scene.anims.generateFrameNumbers('enemy-running', { start: 0, end: 7 }),\n        frameRate: 12,\n        repeat: -1, // Loop forever\n      });\n    }\n\n    if (!this.scene.anims.exists('enemy-punch')) {\n      // Punch animation - 5 frames (0-4)\n      // Sequence: stance (0) -> wind-up (1) -> punch start (2) -> punch_extend (wide, frames 3+4 combined)\n      this.scene.anims.create({\n        key: 'enemy-punch',\n        frames: [\n          { key: 'enemy-punch', frame: 0 },           // stance\n          { key: 'enemy-punch', frame: 1 },           // wind-up\n          { key: 'enemy-punch', frame: 2 },           // punch start\n          { key: 'enemy-punch', frame: 'punch_extend' }, // full extension (400px wide, frames 3+4 combined)\n        ],\n        frameRate: 12,\n        repeat: 0, // Play once\n      });\n    }\n\n    if (!this.scene.anims.exists('enemy-sidekick')) {\n      // Sidekick animation - 6 frames (skipping frame 5)\n      // Sequence: stance (0) -> knee slightly elevated (1) -> knee fully elevated (2) -> leg half-extended (3) -> kick_extend (3+4 combined, skip 5) -> kick_follow (6+7 combined)\n      this.scene.anims.create({\n        key: 'enemy-sidekick',\n        frames: [\n          { key: 'enemy-sidekick', frame: 0 },           // stance\n          { key: 'enemy-sidekick', frame: 1 },           // knee slightly elevated\n          { key: 'enemy-sidekick', frame: 2 },           // knee fully elevated\n          { key: 'enemy-sidekick', frame: 'kick_extend' }, // frames 3+4 combined (skip frame 5)\n          { key: 'enemy-sidekick', frame: 'kick_follow' }, // follow through (400px wide, slots 6+7)\n        ],\n        frameRate: 18,\n        repeat: 0, // Play once\n        yoyo: true, // Play forward then backward\n      });\n    }\n\n\n    if (!this.scene.anims.exists('enemy-getting-punched')) {\n      // Getting punched animation - 5 frames, hurt/damage reaction\n      // Sequence: impact -> recoil -> stunned -> recovering -> recovered\n      this.scene.anims.create({\n        key: 'enemy-getting-punched',\n        frames: [\n          { key: 'enemy-getting-punched', frame: 0 },                // stance\n          { key: 'enemy-getting-punched', frame: 1 },                // crouch prep\n          { key: 'enemy-getting-punched', frame: 2 },                // knee up\n          { key: 'enemy-getting-punched', frame: 3 }, // full extension (400px wide)\n        ],        \n        frameRate: 18,\n        repeat: 0,\n        yoyo: true,\n      });\n    }\n\n  }\n\n  private setupPhysicsBody(): void {\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n\n    // Set physics body size\n    body.setSize(CONFIG.BODY_WIDTH, CONFIG.BODY_HEIGHT);\n\n    // Center the body horizontally, position at bottom of frame (where character is)\n    const offsetX = (CONFIG.FRAME_WIDTH - CONFIG.BODY_WIDTH) / 2;\n    // Character feet are near the bottom of the frame with some padding\n    const bottomPadding = 30; // Space below character's feet in the frame\n    const offsetY = CONFIG.FRAME_HEIGHT - CONFIG.BODY_HEIGHT - bottomPadding;\n    body.setOffset(offsetX, offsetY);\n\n    // Enable gravity and world bounds collision\n    body.setCollideWorldBounds(true);\n    body.setMaxVelocity(CONFIG.MOVE_SPEED, 800);\n    body.setDrag(CONFIG.DRAG, 0);\n  }\n\n  update(): void {\n    if (!this.scene.registry.get('matchStarted')) return;\n\n    const delta = this.scene.game.loop.delta;\n\n    // Update invincibility timer\n    if (this.invincibilityTimer > 0) {\n      this.invincibilityTimer -= delta;\n      if (this.invincibilityTimer <= 0) {\n        this.isInvincible = false;\n      }\n    }\n\n    // Update warning indicator position to follow enemy\n    this.updateWarningPosition();\n\n    // Don't update movement if dead\n    if (this.currentHealth <= 0) {\n      return;\n    }\n\n    this.handleAttack();\n    this.handleMovement();\n    this.handleJump();\n    this.updateState();\n    this.updateFacing();\n  }\n\n  /**\n   * Update the warning indicator position to follow the enemy\n   */\n  private updateWarningPosition(): void {\n    if (this.warningContainer) {\n      // Position above the enemy's head\n      this.warningContainer.setPosition(this.sprite.x, this.sprite.y - 180);\n    }\n  }\n\n  private handleAttack(): void {\n    // Don't allow attacks while already attacking, hurt, dead, or showing warning\n    if (this.currentState === EnemyState.ATTACKING || \n        this.currentState === EnemyState.HURT || \n        this.currentHealth <= 0 ||\n        this.isShowingWarning()) {\n      return;\n    }\n\n    if (this.inputManager.isEnemyPunchPressed()) {\n      this.punch(); // Use the public method which includes warning\n    } else if (this.inputManager.isEnemySidekickPressed()) {\n      this.sidekick(); // Use the public method which includes warning\n    }\n  }\n\n  private performPunch(): void {\n    this.currentState = EnemyState.ATTACKING;\n    this.currentAttackType = 'punch';\n    this.sprite.play('enemy-punch');\n    this.scene.sound.play('punch-sfx', { volume: 0.5 });\n    this.sprite.once('animationcomplete', () => {\n      this.currentAttackType = null;\n      this.currentState = EnemyState.IDLE;\n      this.sprite.play('enemy-idle');\n    });\n  }\n\n  private performSidekick(): void {\n    this.currentState = EnemyState.ATTACKING;\n    // Always use regular sidekick now\n    this.currentAttackType = 'sidekick';\n    this.sprite.play('enemy-sidekick');\n\n    this.scene.sound.play('kick-sfx', { volume: 0.5 });\n    this.sprite.once('animationcomplete', () => {\n      this.currentAttackType = null;\n      this.currentState = EnemyState.IDLE;\n      this.sprite.play('enemy-idle');\n    });\n  }\n\n  private handleMovement(): void {\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n\n    // Don't move while attacking on the ground (except jump sidekick), or while hurt\n    if (this.currentState === EnemyState.HURT ||\n        this.currentState === EnemyState.ATTACKING) {\n      body.setAccelerationX(0);\n      return;\n    }\n\n    // Check if we've reached the target position (for distance-based movement)\n    if (this.targetX !== null) {\n      const reachedTarget = \n        (this.aiMovementDirection === -1 && this.sprite.x <= this.targetX) ||\n        (this.aiMovementDirection === 1 && this.sprite.x >= this.targetX);\n      \n      if (reachedTarget) {\n        // Stop movement\n        this.aiMovementDirection = 0;\n        this.targetX = null;\n        body.setAccelerationX(0);\n        body.setVelocityX(0); // Stop immediately when target reached\n        return;\n      }\n    }\n\n    // Check both keyboard input and AI control\n    const movingLeft = this.inputManager.isEnemyMovingLeft() || this.aiMovementDirection === -1;\n    const movingRight = this.inputManager.isEnemyMovingRight() || this.aiMovementDirection === 1;\n\n    if (movingLeft) {\n      body.setAccelerationX(-CONFIG.ACCELERATION);\n      this.facingRight = false;\n    } else if (movingRight) {\n      body.setAccelerationX(CONFIG.ACCELERATION);\n      this.facingRight = true;\n    } else {\n      body.setAccelerationX(0);\n    }\n  }\n\n  private handleJump(): void {\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n\n    // Check both keyboard input and AI control\n    const jumpRequested = this.inputManager.isEnemyJumpPressed() || this.aiJumpRequested;\n    \n    // Consume the AI jump request (one-shot)\n    if (this.aiJumpRequested) {\n      this.aiJumpRequested = false;\n    }\n\n    // Only allow jump when on ground\n    if (jumpRequested && body.blocked.down) {\n      body.setVelocityY(CONFIG.JUMP_VELOCITY);\n    }\n  }\n\n  private updateState(): void {\n    // Don't change state while attacking or hurt\n    if (this.currentState === EnemyState.ATTACKING || \n        this.currentState === EnemyState.HURT) {\n      return;\n    }\n\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n    const previousState = this.currentState;\n\n    if (!body.blocked.down) {\n      // In the air\n      this.currentState = body.velocity.y < 0 ? EnemyState.JUMPING : EnemyState.FALLING;\n    } else {\n      // On ground\n      this.currentState = Math.abs(body.velocity.x) > 10 ? EnemyState.RUNNING : EnemyState.IDLE;\n    }\n\n    // Play animation when state changes\n    if (this.currentState !== previousState) {\n      this.playAnimationForState();\n    }\n  }\n\n  private playAnimationForState(): void {\n    switch (this.currentState) {\n      case EnemyState.IDLE:\n        if (this.sprite.anims.currentAnim?.key !== 'enemy-idle') {\n          this.sprite.play('enemy-idle');\n        }\n        break;\n      case EnemyState.RUNNING:\n        if (this.sprite.anims.currentAnim?.key !== 'enemy-running') {\n          this.sprite.play('enemy-running');\n        }\n        break;\n      case EnemyState.JUMPING:\n      case EnemyState.FALLING:\n        // Use idle animation for jumping (no jump animation available)\n        if (this.sprite.anims.currentAnim?.key !== 'enemy-idle') {\n          this.sprite.play('enemy-idle');\n        }\n        break;\n    }\n  }\n\n  private updateFacing(): void {\n    // Sprites face right by default, so flip when facing left\n    const shouldFlip = !this.facingRight;\n    if (this.sprite.flipX !== shouldFlip) {\n      this.sprite.setFlipX(shouldFlip);\n    }\n  }\n\n  /**\n   * Show the attack warning indicator with pulsing animation\n   * @param attackType - The type of attack being prepared\n   * @param callback - Function to call when warning completes (executes attack)\n   */\n  private showAttackWarning(attackType: 'punch' | 'sidekick', callback: () => void): void {\n    if (!this.warningContainer || !this.warningGraphics) {\n      // If warning system not available, execute attack immediately\n      callback();\n      return;\n    }\n\n    this.pendingAttack = attackType;\n    this.warningContainer.setVisible(true);\n    this.warningContainer.setAlpha(0);\n    this.warningContainer.setScale(0.5);\n\n    // Record when the attack will execute (for counter-dodge timing)\n    this.attackExecuteTime = this.scene.time.now + CONFIG.ATTACK_WARNING_DURATION;\n\n    // Kill any existing tween\n    if (this.warningTween) {\n      this.warningTween.destroy();\n    }\n\n    // Create pulsing warning animation that fills the full warning duration\n    this.warningTween = this.scene.tweens.add({\n      targets: this.warningContainer,\n      alpha: { from: 0, to: 1 },\n      scale: { from: 0.5, to: 1.2 },\n      duration: CONFIG.ATTACK_WARNING_DURATION / 2,\n      yoyo: true,\n      repeat: 0,\n      ease: 'Sine.easeInOut',\n      onUpdate: () => {\n        // Add shake effect to the container\n        if (this.warningContainer) {\n          const shake = (Math.random() - 0.5) * 4;\n          this.warningContainer.x = this.sprite.x + shake;\n        }\n      },\n      onComplete: () => {\n        this.hideAttackWarning();\n        callback();\n      }\n    });\n\n    // Also add a red tint flash to the enemy sprite\n    this.scene.tweens.add({\n      targets: this.sprite,\n      tint: { from: 0xffffff, to: 0xff6666 },\n      duration: CONFIG.ATTACK_WARNING_DURATION / 3,\n      yoyo: true,\n      repeat: 1,\n      onComplete: () => {\n        this.sprite.clearTint();\n      }\n    });\n  }\n\n  /**\n   * Hide the attack warning indicator\n   */\n  private hideAttackWarning(): void {\n    if (this.warningContainer) {\n      this.warningContainer.setVisible(false);\n      this.warningContainer.setPosition(this.sprite.x, this.sprite.y - 180);\n    }\n    this.pendingAttack = null;\n    \n    if (this.warningTween) {\n      this.warningTween.destroy();\n      this.warningTween = null;\n    }\n  }\n\n  /**\n   * Check if enemy is currently showing attack warning\n   */\n  public isShowingWarning(): boolean {\n    return this.pendingAttack !== null;\n  }\n\n  /**\n   * Get the time remaining until the attack executes (in ms)\n   * Returns 0 if not showing warning\n   */\n  public getTimeUntilAttack(): number {\n    if (!this.isShowingWarning()) {\n      return 0;\n    }\n    return Math.max(0, this.attackExecuteTime - this.scene.time.now);\n  }\n\n  /** Get the underlying Phaser sprite for physics/collisions */\n  getSprite(): Phaser.Physics.Arcade.Sprite {\n    return this.sprite;\n  }\n\n  getState(): EnemyState {\n    return this.currentState;\n  }\n\n  /** Set which direction the enemy faces */\n  setFacing(right: boolean): void {\n    this.facingRight = right;\n    this.sprite.setFlipX(!right); // Sprite faces right by default, flip when facing left\n  }\n\n  /**\n   * Take damage from an attack\n   * @param amount - Damage amount\n   * @param attackerX - X position of attacker for knockback direction\n   * @param attackType - Optional attack type to determine reaction animation\n   */\n  takeDamage(amount: number, attackerX: number, attackType?: string): void {\n    // Don't take damage if invincible or dead\n    if (this.isInvincible || this.currentHealth <= 0) {\n      return;\n    }\n\n    this.currentHealth = Math.max(0, this.currentHealth - amount);\n\n    // Update health bar\n    if (this.healthBar) {\n      this.healthBar.updateHealth(this.currentHealth);\n    }\n\n    // Apply knockback\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n    const knockbackDirection = this.sprite.x < attackerX ? -1 : 1;\n    body.setVelocityX(knockbackDirection * CONFIG.KNOCKBACK_FORCE);\n\n    // Start invincibility\n    this.isInvincible = true;\n    this.invincibilityTimer = CONFIG.INVINCIBILITY_DURATION;\n\n    // Play hurt animation if we know the attack type\n    if (attackType) {\n      this.triggerHurt();\n    }\n\n    // Check if dead\n    if (this.currentHealth <= 0) {\n      // Freeze in place\n      body.setVelocity(0, 0);\n      body.setAcceleration(0, 0);\n    }\n  }\n\n  /**\n   * Trigger the hurt/getting punched animation (face hit)\n   */\n  public triggerHurt(): void {\n    // Don't interrupt if already hurt\n    if (this.currentState === EnemyState.HURT) {\n      return;\n    }\n\n    this.currentState = EnemyState.HURT;\n    this.currentAttackType = null; // Cancel any current attack\n    this.sprite.play('enemy-getting-punched');\n\n    // Return to idle after animation completes\n    this.sprite.once('animationcomplete', () => {\n      this.currentState = EnemyState.IDLE;\n      this.sprite.play('enemy-idle');\n    });\n  }\n\n  /**\n   * Set health bar reference\n   */\n  setHealthBar(healthBar: HealthBar): void {\n    this.healthBar = healthBar;\n  }\n\n  /**\n   * Get current health\n   */\n  getCurrentHealth(): number {\n    return this.currentHealth;\n  }\n\n  /**\n   * Get max health\n   */\n  getMaxHealth(): number {\n    return this.maxHealth;\n  }\n\n  /**\n   * Check if enemy is dead\n   */\n  isDead(): boolean {\n    return this.currentHealth <= 0;\n  }\n\n  /**\n   * Check if enemy is invincible\n   */\n  getIsInvincible(): boolean {\n    return this.isInvincible;\n  }\n\n  /**\n   * Get the current attack hitbox bounds if attacking\n   * Returns null if not attacking or not in hit frame\n   */\n  getAttackHitbox(): Phaser.Geom.Rectangle | null {\n    if (this.currentState !== EnemyState.ATTACKING || !this.currentAttackType) {\n      return null;\n    }\n\n    const anim = this.sprite.anims.currentAnim;\n    if (!anim) return null;\n\n    // Get current frame from sprite's animation manager\n    const animsManager = this.sprite.anims as any;\n    const currentFrame = animsManager.currentFrame;\n    if (!currentFrame) return null;\n\n    // Punch hitbox - check if we're on the punch_extend frame (wide frame, frames 4+5 combined)\n    if (anim.key === 'enemy-punch' && currentFrame.frame.name === 'punch_extend') {\n      const hitboxWidth = 100; // Wider hitbox for the extended punch\n      const hitboxHeight = 60;\n      const offsetX = this.facingRight ? 70 : -70; // Further reach for extended punch\n      const offsetY = -30; // Slightly above center\n\n      // Create hitbox rectangle\n      const hitboxX = this.sprite.x + offsetX - hitboxWidth / 2;\n      const hitboxY = this.sprite.y + offsetY - hitboxHeight / 2;\n\n      return new Phaser.Geom.Rectangle(hitboxX, hitboxY, hitboxWidth, hitboxHeight);\n    }\n\n    // Sidekick hitbox - check if we're on the kick_extend or kick_follow frames (wide frames)\n    if (anim.key === 'enemy-sidekick' && \n        (currentFrame.frame.name === 'kick_extend' || currentFrame.frame.name === 'kick_follow')) {\n      const hitboxWidth = 120; // Wider hitbox for the extended kick\n      const hitboxHeight = 80;\n      const offsetX = this.facingRight ? 90 : -90; // Further reach for extended kick\n      const offsetY = -40; // Slightly above center\n\n      // Create hitbox rectangle\n      const hitboxX = this.sprite.x + offsetX - hitboxWidth / 2;\n      const hitboxY = this.sprite.y + offsetY - hitboxHeight / 2;\n\n      return new Phaser.Geom.Rectangle(hitboxX, hitboxY, hitboxWidth, hitboxHeight);\n    }\n\n    return null;\n  }\n\n  /**\n   * Get damage value for current attack\n   */\n  getAttackDamage(): number {\n    if (this.currentAttackType === 'punch') {\n      return 10; // Same as player punch damage\n    }\n    if (this.currentAttackType === 'sidekick') {\n      return 15; // Sidekick does more damage than punch\n    }\n    return 0;\n  }\n\n  // ============================================\n  // PUBLIC ACTION METHODS (for AI or programmatic control)\n  // ============================================\n\n  /**\n   * Check if the enemy can currently perform an attack\n   * @returns true if attack is allowed\n   */\n  public canAttack(): boolean {\n    return this.currentState !== EnemyState.ATTACKING &&\n           this.currentState !== EnemyState.HURT &&\n           this.currentHealth > 0 &&\n           !this.isShowingWarning();\n  }\n\n  /**\n   * Check if the enemy can currently jump\n   * @returns true if jump is allowed (on ground and not dead)\n   */\n  public canJump(): boolean {\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n    return body.blocked.down && this.currentHealth > 0;\n  }\n\n  /**\n   * Trigger a punch attack (callable by AI or code)\n   * Shows a 300ms warning before the attack executes\n   * @returns true if punch was triggered, false if not allowed\n   */\n  public punch(): boolean {\n    if (!this.canAttack() || this.isShowingWarning()) {\n      return false;\n    }\n    \n    // Show warning, then execute punch after delay\n    this.showAttackWarning('punch', () => {\n      // Double-check we can still attack after the warning\n      if (this.canAttack()) {\n        this.performPunch();\n      }\n    });\n    \n    return true;\n  }\n\n  /**\n   * Trigger a sidekick attack (callable by AI or code)\n   * Shows a 300ms warning before the attack executes\n   * @returns true if sidekick was triggered, false if not allowed\n   */\n  public sidekick(): boolean {\n    if (!this.canAttack() || this.isShowingWarning()) {\n      return false;\n    }\n    \n    // Show warning, then execute sidekick after delay\n    this.showAttackWarning('sidekick', () => {\n      // Double-check we can still attack after the warning\n      if (this.canAttack()) {\n        this.performSidekick();\n      }\n    });\n    \n    return true;\n  }\n\n  /**\n   * Trigger a jump (callable by AI or code)\n   * @returns true if jump was triggered, false if not allowed\n   */\n  public jump(): boolean {\n    if (!this.canJump()) {\n      return false;\n    }\n    this.aiJumpRequested = true;\n    return true;\n  }\n\n  /**\n   * Start moving left (for AI control)\n   * Movement continues until stopMoving() is called\n   */\n  public startMovingLeft(): void {\n    this.aiMovementDirection = -1;\n  }\n\n  /**\n   * Start moving right (for AI control)\n   * Movement continues until stopMoving() is called\n   */\n  public startMovingRight(): void {\n    this.aiMovementDirection = 1;\n  }\n\n  /**\n   * Stop AI-controlled movement\n   */\n  public stopMoving(): void {\n    this.aiMovementDirection = 0;\n    this.targetX = null;\n  }\n\n  /**\n   * Move left by a specific number of pixels\n   * Movement will automatically stop when target is reached\n   * @param pixels - Number of pixels to move\n   */\n  public moveLeftBy(pixels: number): void {\n    this.targetX = this.sprite.x - pixels;\n    this.aiMovementDirection = -1;\n  }\n\n  /**\n   * Move right by a specific number of pixels\n   * Movement will automatically stop when target is reached\n   * @param pixels - Number of pixels to move\n   */\n  public moveRightBy(pixels: number): void {\n    this.targetX = this.sprite.x + pixels;\n    this.aiMovementDirection = 1;\n  }\n\n  /**\n   * Get the current AI movement direction\n   * @returns -1 for left, 0 for none, 1 for right\n   */\n  public getAIMovementDirection(): -1 | 0 | 1 {\n    return this.aiMovementDirection;\n  }\n\n  /**\n   * Check if enemy is currently attacking\n   */\n  public isAttacking(): boolean {\n    return this.currentState === EnemyState.ATTACKING;\n  }\n\n  /**\n   * Get enemy's current X position\n   */\n  public getX(): number {\n    return this.sprite.x;\n  }\n\n  /**\n   * Get enemy's current Y position\n   */\n  public getY(): number {\n    return this.sprite.y;\n  }\n\n  /**\n   * Check if enemy is facing right\n   */\n  public isFacingRight(): boolean {\n    return this.facingRight;\n  }\n}\n","/**\n * Power Booster Entity\n * ====================\n * Collectible power-up that makes the player bigger and stronger.\n * Similar to Mario's mushroom/flower power-ups.\n */\n\nimport Phaser from 'phaser';\nimport { BoosterBar } from '../ui/BoosterBar';\n\n/** Power booster configuration */\nconst CONFIG = {\n  /** Size of the power booster sprite */\n  SCALE: 0.15,\n  /** Floating bob animation amplitude (pixels) */\n  BOB_AMPLITUDE: 8,\n  /** Floating bob animation speed */\n  BOB_SPEED: 2000,\n  /** Glow pulse speed */\n  GLOW_SPEED: 1500,\n  /** Duration of the power boost effect (ms) */\n  BOOST_DURATION: 10000,\n  /** Scale multiplier when powered up */\n  POWER_SCALE: 1.2,\n};\n\nexport class PowerBooster {\n  private scene: Phaser.Scene;\n  private sprite: Phaser.Physics.Arcade.Sprite;\n  private startY: number;\n  private bobTween!: Phaser.Tweens.Tween;\n  private glowTween!: Phaser.Tweens.Tween;\n  private isCollected: boolean = false;\n\n  /** Track if player is currently powered up (shared across all boosters) */\n  private static isPlayerPoweredUp: boolean = false;\n\n  constructor(scene: Phaser.Scene, x: number, y: number) {\n    this.scene = scene;\n    this.startY = y;\n\n    // Create the sprite\n    this.sprite = scene.physics.add.sprite(x, y, 'power-booster');\n    this.sprite.setScale(CONFIG.SCALE);\n    this.sprite.setDepth(5);\n\n    // Disable gravity so it floats\n    const body = this.sprite.body as Phaser.Physics.Arcade.Body;\n    body.setAllowGravity(false);\n    \n    // Set a circular hitbox centered on the cube\n    body.setCircle(this.sprite.width * 0.3, this.sprite.width * 0.2, this.sprite.height * 0.2);\n\n    // Start floating animation\n    this.createFloatingAnimation();\n    \n    // Add glow effect\n    this.createGlowEffect();\n  }\n\n  private createFloatingAnimation(): void {\n    // Floating bob animation\n    this.bobTween = this.scene.tweens.add({\n      targets: this.sprite,\n      y: this.startY - CONFIG.BOB_AMPLITUDE,\n      duration: CONFIG.BOB_SPEED / 2,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1,\n    });\n  }\n\n  private createGlowEffect(): void {\n    // Pulsing glow effect using alpha\n    this.glowTween = this.scene.tweens.add({\n      targets: this.sprite,\n      alpha: { from: 0.8, to: 1 },\n      duration: CONFIG.GLOW_SPEED / 2,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1,\n    });\n\n    // Add a subtle scale pulse for extra \"power\" feel\n    this.scene.tweens.add({\n      targets: this.sprite,\n      scaleX: CONFIG.SCALE * 1.1,\n      scaleY: CONFIG.SCALE * 1.1,\n      duration: CONFIG.GLOW_SPEED,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1,\n    });\n  }\n\n  /**\n   * Called when player collects the power booster\n   */\n  collect(playerSprite: Phaser.Physics.Arcade.Sprite, boosterBar?: BoosterBar): void {\n    if (this.isCollected) return;\n    if (PowerBooster.isPlayerPoweredUp) return; // Can't collect while already powered up\n    this.isCollected = true;\n\n    // Stop animations\n    this.bobTween.stop();\n    this.glowTween.stop();\n\n    // Play power-up sound\n    this.scene.sound.play('power-up-sfx', { volume: 0.7 });\n\n    // Activate the booster bar UI\n    if (boosterBar) {\n      boosterBar.activate(CONFIG.BOOST_DURATION);\n    }\n\n    // Collection visual effect - scale up and fade out\n    this.scene.tweens.add({\n      targets: this.sprite,\n      scale: CONFIG.SCALE * 2,\n      alpha: 0,\n      duration: 300,\n      ease: 'Power2',\n      onComplete: () => {\n        this.sprite.destroy();\n      },\n    });\n\n    // Apply power boost to player\n    this.applyPowerBoost(playerSprite);\n\n    // Particle burst effect\n    this.createCollectionParticles();\n  }\n\n  private applyPowerBoost(playerSprite: Phaser.Physics.Arcade.Sprite): void {\n    const originalScaleX = playerSprite.scaleX;\n    const originalScaleY = playerSprite.scaleY;\n\n    // Mark player as powered up\n    PowerBooster.isPlayerPoweredUp = true;\n\n    // Scale up the player (power boost!)\n    this.scene.tweens.add({\n      targets: playerSprite,\n      scaleX: originalScaleX * CONFIG.POWER_SCALE,\n      scaleY: originalScaleY * CONFIG.POWER_SCALE,\n      duration: 300,\n      ease: 'Back.easeOut',\n    });\n\n    // Add a glowing tint effect to player\n    playerSprite.setTint(0x00ffff);\n\n    // Flash effect\n    this.scene.tweens.add({\n      targets: playerSprite,\n      alpha: { from: 0.5, to: 1 },\n      duration: 100,\n      repeat: 3,\n      yoyo: true,\n      onComplete: () => {\n        playerSprite.setAlpha(1); // Ensure alpha is reset to full\n      },\n    });\n\n    // Revert after duration\n    this.scene.time.delayedCall(CONFIG.BOOST_DURATION, () => {\n      // Scale back down\n      this.scene.tweens.add({\n        targets: playerSprite,\n        scaleX: originalScaleX,\n        scaleY: originalScaleY,\n        duration: 500,\n        ease: 'Power2',\n      });\n      // Remove tint\n      playerSprite.clearTint();\n      // Allow collecting boosters again\n      PowerBooster.isPlayerPoweredUp = false;\n    });\n  }\n\n  private createCollectionParticles(): void {\n    // Create particle emitter for collection effect\n    const particles = this.scene.add.particles(this.sprite.x, this.sprite.y, 'power-booster', {\n      scale: { start: 0.05, end: 0 },\n      speed: { min: 50, max: 150 },\n      angle: { min: 0, max: 360 },\n      lifespan: 500,\n      quantity: 8,\n      blendMode: 'ADD',\n    });\n\n    // Stop emitting after burst\n    particles.explode(8);\n\n    // Clean up after particles fade\n    this.scene.time.delayedCall(600, () => {\n      particles.destroy();\n    });\n  }\n\n  /** Get the sprite for collision detection */\n  getSprite(): Phaser.Physics.Arcade.Sprite {\n    return this.sprite;\n  }\n\n  /** Check if already collected */\n  isAlreadyCollected(): boolean {\n    return this.isCollected;\n  }\n\n  /** Get boost duration for external use */\n  static getBoostDuration(): number {\n    return CONFIG.BOOST_DURATION;\n  }\n\n  /** Get power scale for external use */\n  static getPowerScale(): number {\n    return CONFIG.POWER_SCALE;\n  }\n\n  /** Reset static state (call when restarting the game) */\n  static resetState(): void {\n    PowerBooster.isPlayerPoweredUp = false;\n  }\n}\n","/**\n * Input Manager\n * ==============\n * Centralizes all input handling - keyboard, gamepad, etc.\n */\n\nimport Phaser from 'phaser';\n\nexport class InputManager {\n  private scene: Phaser.Scene;\n  private cursors!: Phaser.Types.Input.Keyboard.CursorKeys;\n  private wasd!: {\n    W: Phaser.Input.Keyboard.Key;\n    A: Phaser.Input.Keyboard.Key;\n    S: Phaser.Input.Keyboard.Key;\n    D: Phaser.Input.Keyboard.Key;\n  };\n  private spaceKey!: Phaser.Input.Keyboard.Key;\n  private punchKey!: Phaser.Input.Keyboard.Key;      // C - punch (double C = combo)\n  private uppercutKey!: Phaser.Input.Keyboard.Key;   // V - uppercut (direct)\n  private kickKey!: Phaser.Input.Keyboard.Key;       // X - kick (double X = combo)\n  private sidekickKey!: Phaser.Input.Keyboard.Key;   // Z - sidekick (direct)\n  private interactKey!: Phaser.Input.Keyboard.Key;\n  private debugHurtKey!: Phaser.Input.Keyboard.Key;  // P - debug trigger for hurt animation (face)\n  private debugHurtStomachKey!: Phaser.Input.Keyboard.Key;  // O - debug trigger for stomach hurt animation\n  private dodgeKey!: Phaser.Input.Keyboard.Key;       // I - dodge\n  private matrixDodgeKey!: Phaser.Input.Keyboard.Key; // L - matrix dodge\n  private counterDodgeKey!: Phaser.Input.Keyboard.Key; // U - counter-dodge (during enemy warning)\n\n  // Enemy control keys\n  private enemyJumpKey!: Phaser.Input.Keyboard.Key;   // Y - enemy jump\n  private enemyLeftKey!: Phaser.Input.Keyboard.Key;   // G - enemy run left\n  private enemyRightKey!: Phaser.Input.Keyboard.Key;  // J - enemy run right\n  private enemyCrouchKey!: Phaser.Input.Keyboard.Key; // H - enemy crouch\n  private enemyPunchKey!: Phaser.Input.Keyboard.Key;   // U - enemy punch\n  private enemySidekickKey!: Phaser.Input.Keyboard.Key; // K - enemy sidekick\n\n  constructor(scene: Phaser.Scene) {\n    this.scene = scene;\n    this.setupKeyboardInput();\n  }\n\n  private setupKeyboardInput(): void {\n    const keyboard = this.scene.input.keyboard;\n    if (!keyboard) return;\n\n    this.cursors = keyboard.createCursorKeys();\n    this.wasd = {\n      W: keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n      A: keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n      S: keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n      D: keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),\n    };\n    this.spaceKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.punchKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.C);      // C - punch\n    this.uppercutKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.V);   // V - uppercut\n    this.kickKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.X);       // X - kick\n    this.sidekickKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);   // Z - sidekick\n    this.interactKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);\n    this.debugHurtKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P); // P - debug hurt (face)\n    this.debugHurtStomachKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.O); // O - debug hurt (stomach)\n    this.dodgeKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.I);     // I - dodge\n    this.matrixDodgeKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.L); // L - matrix dodge\n    this.counterDodgeKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.U); // U - counter-dodge\n\n    // Enemy controls\n    this.enemyJumpKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Y);   // Y - enemy jump\n    this.enemyLeftKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);   // G - enemy run left\n    this.enemyRightKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.J);  // J - enemy run right\n    this.enemyCrouchKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H); // H - enemy crouch\n    this.enemyPunchKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.U);   // U - enemy punch\n    this.enemySidekickKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.K); // K - enemy sidekick\n  }\n\n  isMovingLeft(): boolean {\n    return this.cursors?.left.isDown || this.wasd?.A.isDown || false;\n  }\n\n  isMovingRight(): boolean {\n    return this.cursors?.right.isDown || this.wasd?.D.isDown || false;\n  }\n\n  isMovingUp(): boolean {\n    return this.cursors?.up.isDown || this.wasd?.W.isDown || false;\n  }\n\n  isMovingDown(): boolean {\n    return this.cursors?.down.isDown || this.wasd?.S.isDown || false;\n  }\n\n  isJumpPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.spaceKey) ||\n      Phaser.Input.Keyboard.JustDown(this.cursors?.up) ||\n      Phaser.Input.Keyboard.JustDown(this.wasd?.W);\n  }\n\n  isJumpHeld(): boolean {\n    return this.spaceKey?.isDown || this.cursors?.up.isDown || this.wasd?.W.isDown || false;\n  }\n\n  // C key - punch (double C = punch + uppercut combo)\n  isPunchPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.punchKey);\n  }\n\n  // V key - direct uppercut\n  isUppercutPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.uppercutKey);\n  }\n\n  // X key - kick (double X = kick + sidekick combo)\n  isKickPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.kickKey);\n  }\n\n  // Z key - direct sidekick\n  isSidekickPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.sidekickKey);\n  }\n\n  isInteractPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.interactKey);\n  }\n\n  // P key - debug trigger for hurt animation (temporary, for testing without enemies)\n  isDebugHurtPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.debugHurtKey);\n  }\n\n  // O key - debug trigger for stomach hurt animation (temporary, for testing without enemies)\n  isDebugHurtStomachPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.debugHurtStomachKey);\n  }\n\n  // I key - dodge\n  isDodgePressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.dodgeKey);\n  }\n\n  // L key - matrix dodge\n  isMatrixDodgePressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.matrixDodgeKey);\n  }\n\n  // U key - counter-dodge (during enemy attack warning)\n  isCounterDodgePressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.counterDodgeKey);\n  }\n\n  getHorizontalAxis(): number {\n    let axis = 0;\n    if (this.isMovingLeft()) axis -= 1;\n    if (this.isMovingRight()) axis += 1;\n    return axis;\n  }\n\n  // Enemy controls\n  isEnemyMovingLeft(): boolean {\n    return this.enemyLeftKey?.isDown || false;\n  }\n\n  isEnemyMovingRight(): boolean {\n    return this.enemyRightKey?.isDown || false;\n  }\n\n  isEnemyJumpPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.enemyJumpKey);\n  }\n\n  isEnemyCrouchPressed(): boolean {\n    return this.enemyCrouchKey?.isDown || false;\n  }\n\n  isEnemyPunchPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.enemyPunchKey);\n  }\n\n  isEnemySidekickPressed(): boolean {\n    return Phaser.Input.Keyboard.JustDown(this.enemySidekickKey);\n  }\n}\n","/**\n * Booster Bar UI\n * ==============\n * A stylish progress bar that appears when the player has an active power boost.\n * Shows remaining time with animated effects.\n */\n\nimport Phaser from 'phaser';\n\n/** Booster bar configuration */\nconst CONFIG = {\n  /** Bar dimensions */\n  WIDTH: 200,\n  HEIGHT: 20,\n  /** Position from top-right corner */\n  MARGIN_X: 40,\n  MARGIN_Y: 40,\n  /** Colors */\n  BG_COLOR: 0x1a1a2e,\n  FILL_COLOR: 0x00ffff,\n  BORDER_COLOR: 0x4a4a6a,\n  GLOW_COLOR: 0x00ffff,\n  /** Animation */\n  PULSE_SPEED: 800,\n  /** Corner radius */\n  BORDER_RADIUS: 10,\n};\n\nexport class BoosterBar {\n  private scene: Phaser.Scene;\n  private container: Phaser.GameObjects.Container;\n  private background: Phaser.GameObjects.Graphics;\n  private fillBar: Phaser.GameObjects.Graphics;\n  private border: Phaser.GameObjects.Graphics;\n  private glowEffect: Phaser.GameObjects.Graphics;\n  private icon: Phaser.GameObjects.Image;\n  private label: Phaser.GameObjects.Text;\n  private timerText: Phaser.GameObjects.Text;\n  \n  private currentProgress: number = 1;\n  private targetProgress: number = 1;\n  private isActive: boolean = false;\n  private duration: number = 0;\n  private elapsed: number = 0;\n  private pulseTween: Phaser.Tweens.Tween | null = null;\n\n  constructor(scene: Phaser.Scene) {\n    this.scene = scene;\n\n    // Create container for all bar elements (positioned top-right)\n    const x = scene.cameras.main.width - CONFIG.WIDTH - CONFIG.MARGIN_X - 40;\n    const y = CONFIG.MARGIN_Y;\n    this.container = scene.add.container(x, y);\n    this.container.setScrollFactor(0); // Fixed to camera\n    this.container.setDepth(1000);\n    this.container.setAlpha(0); // Start hidden\n\n    // Create glow effect (behind everything)\n    this.glowEffect = scene.add.graphics();\n    this.container.add(this.glowEffect);\n\n    // Create background\n    this.background = scene.add.graphics();\n    this.drawBackground();\n    this.container.add(this.background);\n\n    // Create fill bar\n    this.fillBar = scene.add.graphics();\n    this.container.add(this.fillBar);\n\n    // Create border\n    this.border = scene.add.graphics();\n    this.drawBorder();\n    this.container.add(this.border);\n\n    // Create icon (power booster icon on the left)\n    this.icon = scene.add.image(-25, CONFIG.HEIGHT / 2, 'power-booster');\n    this.icon.setScale(0.04);\n    this.container.add(this.icon);\n\n    // Create label\n    this.label = scene.add.text(CONFIG.WIDTH / 2, -8, 'POWER BOOST', {\n      fontFamily: 'monospace',\n      fontSize: '10px',\n      color: '#00ffff',\n      fontStyle: 'bold',\n    });\n    this.label.setOrigin(0.5, 1);\n    this.container.add(this.label);\n\n    // Create timer text\n    this.timerText = scene.add.text(CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2, '', {\n      fontFamily: 'monospace',\n      fontSize: '12px',\n      color: '#ffffff',\n      fontStyle: 'bold',\n    });\n    this.timerText.setOrigin(0.5, 0.5);\n    this.container.add(this.timerText);\n\n    // Update loop\n    scene.events.on('update', this.update, this);\n  }\n\n  private drawBackground(): void {\n    this.background.clear();\n    this.background.fillStyle(CONFIG.BG_COLOR, 0.9);\n    this.background.fillRoundedRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT, CONFIG.BORDER_RADIUS);\n  }\n\n  private drawBorder(): void {\n    this.border.clear();\n    this.border.lineStyle(2, CONFIG.BORDER_COLOR, 1);\n    this.border.strokeRoundedRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT, CONFIG.BORDER_RADIUS);\n  }\n\n  private drawFill(progress: number): void {\n    this.fillBar.clear();\n    \n    if (progress <= 0) return;\n\n    const fillWidth = Math.max(0, (CONFIG.WIDTH - 4) * progress);\n    \n    // Gradient effect using multiple rectangles\n    const gradient = this.getGradientColor(progress);\n    \n    this.fillBar.fillStyle(gradient, 1);\n    this.fillBar.fillRoundedRect(\n      2, \n      2, \n      fillWidth, \n      CONFIG.HEIGHT - 4, \n      CONFIG.BORDER_RADIUS - 2\n    );\n\n    // Add shine effect on top\n    this.fillBar.fillStyle(0xffffff, 0.3);\n    this.fillBar.fillRoundedRect(\n      2, \n      2, \n      fillWidth, \n      (CONFIG.HEIGHT - 4) / 3, \n      { tl: CONFIG.BORDER_RADIUS - 2, tr: CONFIG.BORDER_RADIUS - 2, bl: 0, br: 0 }\n    );\n  }\n\n  private drawGlow(progress: number): void {\n    this.glowEffect.clear();\n    \n    if (progress <= 0) return;\n\n    const fillWidth = (CONFIG.WIDTH - 4) * progress;\n    \n    // Outer glow\n    this.glowEffect.fillStyle(CONFIG.GLOW_COLOR, 0.2);\n    this.glowEffect.fillRoundedRect(-4, -4, fillWidth + 8, CONFIG.HEIGHT + 8, CONFIG.BORDER_RADIUS + 2);\n  }\n\n  private getGradientColor(progress: number): number {\n    // Change color based on remaining time\n    if (progress > 0.6) return 0x00ffff; // Cyan - plenty of time\n    if (progress > 0.3) return 0xffff00; // Yellow - warning\n    return 0xff4444; // Red - almost out!\n  }\n\n  /**\n   * Activate the booster bar with a duration\n   */\n  activate(durationMs: number): void {\n    this.duration = durationMs;\n    this.elapsed = 0;\n    this.currentProgress = 1;\n    this.targetProgress = 1;\n    this.isActive = true;\n\n    // Fade in\n    this.scene.tweens.add({\n      targets: this.container,\n      alpha: 1,\n      duration: 300,\n      ease: 'Power2',\n    });\n\n    // Start pulse animation\n    this.startPulseAnimation();\n\n    // Pop-in effect for icon\n    this.scene.tweens.add({\n      targets: this.icon,\n      scale: { from: 0.08, to: 0.04 },\n      duration: 400,\n      ease: 'Back.easeOut',\n    });\n  }\n\n  /**\n   * Deactivate and hide the bar\n   */\n  deactivate(): void {\n    this.isActive = false;\n\n    // Stop pulse\n    if (this.pulseTween) {\n      this.pulseTween.stop();\n      this.pulseTween = null;\n    }\n\n    // Fade out\n    this.scene.tweens.add({\n      targets: this.container,\n      alpha: 0,\n      duration: 500,\n      ease: 'Power2',\n    });\n  }\n\n  private startPulseAnimation(): void {\n    // Pulse the glow effect\n    this.pulseTween = this.scene.tweens.add({\n      targets: this.glowEffect,\n      alpha: { from: 0.5, to: 1 },\n      duration: CONFIG.PULSE_SPEED,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1,\n    });\n\n    // Pulse the icon\n    this.scene.tweens.add({\n      targets: this.icon,\n      scale: { from: 0.04, to: 0.045 },\n      duration: CONFIG.PULSE_SPEED,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1,\n    });\n  }\n\n  private update(_time: number, delta: number): void {\n    if (!this.isActive) return;\n\n    // Update elapsed time\n    this.elapsed += delta;\n    \n    // Calculate progress (1 = full, 0 = empty)\n    this.targetProgress = Math.max(0, 1 - (this.elapsed / this.duration));\n    \n    // Smooth progress update\n    this.currentProgress += (this.targetProgress - this.currentProgress) * 0.1;\n\n    // Update visuals\n    this.drawFill(this.currentProgress);\n    this.drawGlow(this.currentProgress);\n\n    // Update timer text\n    const remainingSeconds = Math.ceil((this.duration - this.elapsed) / 1000);\n    this.timerText.setText(`${Math.max(0, remainingSeconds)}s`);\n\n    // Update label color based on time\n    if (this.currentProgress <= 0.3) {\n      this.label.setColor('#ff4444');\n      this.timerText.setColor('#ff4444');\n    } else if (this.currentProgress <= 0.6) {\n      this.label.setColor('#ffff00');\n      this.timerText.setColor('#ffff00');\n    } else {\n      this.label.setColor('#00ffff');\n      this.timerText.setColor('#ffffff');\n    }\n\n    // Check if expired\n    if (this.elapsed >= this.duration) {\n      this.deactivate();\n    }\n  }\n\n  /** Check if currently active */\n  getIsActive(): boolean {\n    return this.isActive;\n  }\n\n  /** Destroy the bar */\n  destroy(): void {\n    this.scene.events.off('update', this.update, this);\n    this.container.destroy();\n  }\n}\n","/**\n * Pause Menu UI\n * =============\n * Overlay menu that appears when the game is paused.\n * Provides options to Resume, Restart, or Quit to main menu.\n * Supports both mouse and keyboard navigation.\n */\n\nimport Phaser from 'phaser';\nimport { GAME_WIDTH, GAME_HEIGHT } from '../config/GameConfig';\n\n/** Pause menu configuration - Tech-noir style matching main menu */\nconst CONFIG = {\n  /** Overlay color and opacity */\n  OVERLAY_COLOR: 0x000000,\n  OVERLAY_ALPHA: 0.6,\n  /** Panel styling */\n  PANEL_WIDTH: 420,\n  PANEL_HEIGHT: 420,\n  PANEL_COLOR: 0x1e293b,\n  PANEL_BORDER_COLOR: 0x64748b,\n  PANEL_BORDER_WIDTH: 2,\n  BORDER_RADIUS: 12,\n  /** Button styling */\n  BUTTON_WIDTH: 320,\n  BUTTON_HEIGHT: 60,\n  BUTTON_COLOR: 0x1e293b,\n  BUTTON_HOVER_COLOR: 0x0f2a1f,\n  BUTTON_SELECTED_COLOR: 0x4ade80, // Green accent\n  BUTTON_TEXT_COLOR: '#ffffff',\n  BUTTON_SELECTED_TEXT_COLOR: '#4ade80',\n  BUTTON_SPACING: 25,\n  /** Font */\n  FONT_FAMILY: 'Quantico',\n};\n\n/** Button data structure */\ninterface MenuButton {\n  bg: Phaser.GameObjects.Graphics;\n  text: Phaser.GameObjects.Text;\n  hitArea: Phaser.GameObjects.Rectangle;\n  callback: () => void;\n}\n\nexport class PauseMenu {\n  private scene: Phaser.Scene;\n  private container: Phaser.GameObjects.Container;\n  private overlay: Phaser.GameObjects.Rectangle;\n  private isVisible: boolean = false;\n  \n  // Callback to check if pausing is allowed (e.g., not when game is over)\n  private canPauseCallback: (() => boolean) | null = null;\n  \n  // Keyboard navigation\n  private buttons: MenuButton[] = [];\n  private selectedIndex: number = 0;\n  \n  // Input keys\n  private escKey: Phaser.Input.Keyboard.Key | null = null;\n  private upKey: Phaser.Input.Keyboard.Key | null = null;\n  private downKey: Phaser.Input.Keyboard.Key | null = null;\n  private wKey: Phaser.Input.Keyboard.Key | null = null;\n  private sKey: Phaser.Input.Keyboard.Key | null = null;\n  private enterKey: Phaser.Input.Keyboard.Key | null = null;\n  private spaceKey: Phaser.Input.Keyboard.Key | null = null;\n\n  constructor(scene: Phaser.Scene, canPauseCallback?: () => boolean) {\n    this.scene = scene;\n    this.canPauseCallback = canPauseCallback ?? null;\n\n    // Create overlay (full screen darkening)\n    this.overlay = scene.add.rectangle(\n      GAME_WIDTH / 2,\n      GAME_HEIGHT / 2,\n      GAME_WIDTH,\n      GAME_HEIGHT,\n      CONFIG.OVERLAY_COLOR,\n      CONFIG.OVERLAY_ALPHA\n    );\n    this.overlay.setScrollFactor(0);\n    this.overlay.setDepth(2000);\n    this.overlay.setVisible(false);\n    this.overlay.setInteractive(); // Block clicks to game below\n\n    // Create container for menu elements\n    this.container = scene.add.container(GAME_WIDTH / 2, GAME_HEIGHT / 2);\n    this.container.setScrollFactor(0);\n    this.container.setDepth(2001);\n    this.container.setVisible(false);\n\n    this.createPanel();\n    this.createTitle();\n    this.createButtons();\n    this.setupInput();\n  }\n\n  private createPanel(): void {\n    // Panel background\n    const panel = this.scene.add.graphics();\n    \n    const x = -CONFIG.PANEL_WIDTH / 2;\n    const y = -CONFIG.PANEL_HEIGHT / 2;\n    const width = CONFIG.PANEL_WIDTH;\n    const height = CONFIG.PANEL_HEIGHT;\n\n    // Shadow\n    panel.fillStyle(0x000000, 0.4);\n    panel.fillRoundedRect(x + 6, y + 6, width, height, CONFIG.BORDER_RADIUS);\n    \n    // Main panel fill\n    panel.fillStyle(CONFIG.PANEL_COLOR, 0.92);\n    panel.fillRoundedRect(x, y, width, height, CONFIG.BORDER_RADIUS);\n    \n    // Subtle border\n    panel.lineStyle(CONFIG.PANEL_BORDER_WIDTH, CONFIG.PANEL_BORDER_COLOR, 0.6);\n    panel.strokeRoundedRect(x, y, width, height, CONFIG.BORDER_RADIUS);\n\n    // Tech corner decorations\n    const cornerSize = 20;\n    const cornerOffset = 6;\n    panel.lineStyle(2, CONFIG.BUTTON_SELECTED_COLOR, 0.7);\n\n    // Top-left corner\n    panel.beginPath();\n    panel.moveTo(x - cornerOffset, y + cornerSize);\n    panel.lineTo(x - cornerOffset, y - cornerOffset);\n    panel.lineTo(x + cornerSize, y - cornerOffset);\n    panel.strokePath();\n\n    // Top-right corner\n    panel.beginPath();\n    panel.moveTo(x + width - cornerSize, y - cornerOffset);\n    panel.lineTo(x + width + cornerOffset, y - cornerOffset);\n    panel.lineTo(x + width + cornerOffset, y + cornerSize);\n    panel.strokePath();\n\n    // Bottom-left corner\n    panel.beginPath();\n    panel.moveTo(x - cornerOffset, y + height - cornerSize);\n    panel.lineTo(x - cornerOffset, y + height + cornerOffset);\n    panel.lineTo(x + cornerSize, y + height + cornerOffset);\n    panel.strokePath();\n\n    // Bottom-right corner\n    panel.beginPath();\n    panel.moveTo(x + width - cornerSize, y + height + cornerOffset);\n    panel.lineTo(x + width + cornerOffset, y + height + cornerOffset);\n    panel.lineTo(x + width + cornerOffset, y + height - cornerSize);\n    panel.strokePath();\n\n    // Subtle inner highlight at top\n    panel.lineStyle(1, 0x94a3b8, 0.2);\n    panel.lineBetween(x + 30, y + 3, x + width - 30, y + 3);\n\n    this.container.add(panel);\n  }\n\n  private createTitle(): void {\n    // Subtitle\n    const subtitle = this.scene.add.text(0, -CONFIG.PANEL_HEIGHT / 2 + 60, 'Game is paused', {\n      fontFamily: CONFIG.FONT_FAMILY,\n      fontSize: '30px',\n      color: '#94a3b8',\n    });\n    subtitle.setOrigin(0.5);\n    this.container.add(subtitle);\n  }\n\n  private createButtons(): void {\n    const buttonY = -50;\n    \n    // Resume button\n    this.createButton(0, buttonY, 'RESUME', () => this.hide());\n    \n    // Restart button\n    this.createButton(0, buttonY + CONFIG.BUTTON_HEIGHT + CONFIG.BUTTON_SPACING, 'RESTART', () => this.restart());\n    \n    // Quit button\n    this.createButton(0, buttonY + (CONFIG.BUTTON_HEIGHT + CONFIG.BUTTON_SPACING) * 2, 'QUIT TO MENU', () => this.quit());\n\n    // Navigation hint\n    const hint = this.scene.add.text(0, CONFIG.PANEL_HEIGHT / 2 - 30, 'â†‘â†“ Navigate  â€¢  ENTER Select  â€¢  ESC Resume', {\n      fontFamily: CONFIG.FONT_FAMILY,\n      fontSize: '12px',\n      color: '#64748b',\n    });\n    hint.setOrigin(0.5);\n    this.container.add(hint);\n  }\n\n  private createButton(x: number, y: number, text: string, callback: () => void): void {\n    const index = this.buttons.length;\n    \n    // Button background\n    const bg = this.scene.add.graphics();\n    this.drawButton(bg, CONFIG.BUTTON_COLOR);\n    bg.setPosition(x, y);\n    this.container.add(bg);\n\n    // Button text\n    const buttonText = this.scene.add.text(x, y, text, {\n      fontFamily: CONFIG.FONT_FAMILY,\n      fontSize: '24px',\n      color: CONFIG.BUTTON_TEXT_COLOR,\n      stroke: '#000000',\n      strokeThickness: 3,\n    });\n    buttonText.setOrigin(0.5);\n    this.container.add(buttonText);\n\n    // Interactive zone\n    const hitArea = this.scene.add.rectangle(\n      x,\n      y,\n      CONFIG.BUTTON_WIDTH,\n      CONFIG.BUTTON_HEIGHT,\n      0xffffff,\n      0\n    );\n    hitArea.setInteractive({ useHandCursor: true });\n    this.container.add(hitArea);\n\n    // Store button reference\n    const button: MenuButton = { bg, text: buttonText, hitArea, callback };\n    this.buttons.push(button);\n\n    // Mouse hover - select this button\n    hitArea.on('pointerover', () => {\n      this.selectButton(index);\n    });\n\n    hitArea.on('pointerdown', () => {\n      buttonText.setScale(0.95);\n    });\n\n    hitArea.on('pointerup', () => {\n      buttonText.setScale(1.05);\n      callback();\n    });\n  }\n\n  private drawButton(graphics: Phaser.GameObjects.Graphics, color: number, selected: boolean = false): void {\n    graphics.clear();\n    \n    const x = -CONFIG.BUTTON_WIDTH / 2;\n    const y = -CONFIG.BUTTON_HEIGHT / 2;\n    const width = CONFIG.BUTTON_WIDTH;\n    const height = CONFIG.BUTTON_HEIGHT;\n\n    // Draw glow effect for selected button\n    if (selected) {\n      for (let i = 5; i > 0; i--) {\n        graphics.lineStyle(i * 2.5, CONFIG.BUTTON_SELECTED_COLOR, 0.08);\n        graphics.strokeRoundedRect(x - i * 2, y - i * 2, width + i * 4, height + i * 4, 8);\n      }\n    }\n    \n    // Button fill\n    graphics.fillStyle(color, 0.9);\n    graphics.fillRoundedRect(x, y, width, height, 8);\n    \n    // Button border\n    const borderColor = selected ? 0xe0f2e9 : 0x64748b;\n    graphics.lineStyle(selected ? 3 : 2, borderColor, 1);\n    graphics.strokeRoundedRect(x, y, width, height, 8);\n\n    // Tech corner decorations\n    const cornerSize = 12;\n    const cornerOffset = 4;\n    graphics.lineStyle(2, borderColor, selected ? 1 : 0.6);\n\n    // Top-left corner\n    graphics.beginPath();\n    graphics.moveTo(x - cornerOffset, y + cornerSize);\n    graphics.lineTo(x - cornerOffset, y - cornerOffset);\n    graphics.lineTo(x + cornerSize, y - cornerOffset);\n    graphics.strokePath();\n\n    // Top-right corner\n    graphics.beginPath();\n    graphics.moveTo(x + width - cornerSize, y - cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y - cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y + cornerSize);\n    graphics.strokePath();\n\n    // Bottom-left corner\n    graphics.beginPath();\n    graphics.moveTo(x - cornerOffset, y + height - cornerSize);\n    graphics.lineTo(x - cornerOffset, y + height + cornerOffset);\n    graphics.lineTo(x + cornerSize, y + height + cornerOffset);\n    graphics.strokePath();\n\n    // Bottom-right corner\n    graphics.beginPath();\n    graphics.moveTo(x + width - cornerSize, y + height + cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y + height + cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y + height - cornerSize);\n    graphics.strokePath();\n\n    // Left accent line for selected button\n    if (selected) {\n      graphics.lineStyle(4, CONFIG.BUTTON_SELECTED_COLOR, 0.9);\n      graphics.beginPath();\n      graphics.moveTo(x, y + 12);\n      graphics.lineTo(x, y + height - 12);\n      graphics.strokePath();\n    }\n  }\n\n  private selectButton(index: number): void {\n    // Clamp index\n    if (index < 0) index = this.buttons.length - 1;\n    if (index >= this.buttons.length) index = 0;\n    \n    // Update selection\n    const prevIndex = this.selectedIndex;\n    this.selectedIndex = index;\n\n    // Update previous button (deselect)\n    if (prevIndex !== index && this.buttons[prevIndex]) {\n      const prevButton = this.buttons[prevIndex];\n      this.drawButton(prevButton.bg, CONFIG.BUTTON_COLOR, false);\n      prevButton.text.setColor(CONFIG.BUTTON_TEXT_COLOR);\n      prevButton.text.setScale(1);\n    }\n\n    // Update current button (select)\n    const button = this.buttons[index];\n    this.drawButton(button.bg, CONFIG.BUTTON_HOVER_COLOR, true);\n    button.text.setColor(CONFIG.BUTTON_SELECTED_TEXT_COLOR);\n    button.text.setScale(1.05);\n    this.scene.sound.play('power-up-sfx', { volume: 0.2 });\n\n    // Play selection sound (optional - subtle feedback)\n    // this.scene.sound.play('menu-move', { volume: 0.3 });\n  }\n\n  private confirmSelection(): void {\n    const button = this.buttons[this.selectedIndex];\n    if (button) {\n      // Visual feedback\n      button.text.setScale(0.95);\n      this.scene.time.delayedCall(100, () => {\n        button.text.setScale(1.05);\n        button.callback();\n      });\n    }\n  }\n\n  private setupInput(): void {\n    const keyboard = this.scene.input.keyboard;\n    if (!keyboard) return;\n\n    // ESC key to toggle pause\n    this.escKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ESC);\n    this.escKey.on('down', () => this.toggle());\n\n    // Navigation keys\n    this.upKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP);\n    this.downKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN);\n    this.wKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.sKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n\n    // Selection keys\n    this.enterKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);\n    this.spaceKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // Up navigation\n    this.upKey.on('down', () => {\n      if (this.isVisible) this.selectButton(this.selectedIndex - 1);\n    });\n    this.wKey.on('down', () => {\n      if (this.isVisible) this.selectButton(this.selectedIndex - 1);\n    });\n\n    // Down navigation\n    this.downKey.on('down', () => {\n      if (this.isVisible) this.selectButton(this.selectedIndex + 1);\n    });\n    this.sKey.on('down', () => {\n      if (this.isVisible) this.selectButton(this.selectedIndex + 1);\n    });\n\n    // Confirm selection\n    this.enterKey.on('down', () => {\n      if (this.isVisible) this.confirmSelection();\n    });\n    this.spaceKey.on('down', () => {\n      if (this.isVisible) this.confirmSelection();\n    });\n  }\n\n  /** Show the pause menu */\n  show(): void {\n    if (this.isVisible) return;\n    this.isVisible = true;\n\n    // Pause physics\n    this.scene.physics.pause();\n\n    // Reset selection to first button\n    this.selectedIndex = 0;\n    this.buttons.forEach((button, index) => {\n      const isSelected = index === 0;\n      this.drawButton(button.bg, isSelected ? CONFIG.BUTTON_HOVER_COLOR : CONFIG.BUTTON_COLOR, isSelected);\n      button.text.setColor(isSelected ? CONFIG.BUTTON_SELECTED_TEXT_COLOR : CONFIG.BUTTON_TEXT_COLOR);\n      button.text.setScale(isSelected ? 1.05 : 1);\n    });\n\n    // Show elements\n    this.overlay.setVisible(true);\n    this.container.setVisible(true);\n\n    // Fade in animation\n    this.overlay.setAlpha(0);\n    this.container.setScale(0.8);\n    this.container.setAlpha(0);\n\n    this.scene.tweens.add({\n      targets: this.overlay,\n      alpha: CONFIG.OVERLAY_ALPHA,\n      duration: 200,\n      ease: 'Power2',\n    });\n\n    this.scene.tweens.add({\n      targets: this.container,\n      scale: 1,\n      alpha: 1,\n      duration: 300,\n      ease: 'Back.easeOut',\n    });\n  }\n\n  /** Hide the pause menu */\n  hide(): void {\n    if (!this.isVisible) return;\n    this.isVisible = false;\n\n    // Animate out\n    this.scene.tweens.add({\n      targets: this.overlay,\n      alpha: 0,\n      duration: 200,\n      ease: 'Power2',\n    });\n\n    this.scene.tweens.add({\n      targets: this.container,\n      scale: 0.8,\n      alpha: 0,\n      duration: 200,\n      ease: 'Power2',\n      onComplete: () => {\n        this.overlay.setVisible(false);\n        this.container.setVisible(false);\n        // Resume physics\n        this.scene.physics.resume();\n      },\n    });\n  }\n\n  /** Toggle pause menu visibility */\n  toggle(): void {\n    if (this.isVisible) {\n      this.hide();\n    } else {\n      // Check if pausing is allowed (e.g., not when game is over)\n      if (this.canPauseCallback && !this.canPauseCallback()) {\n        return;\n      }\n      this.show();\n    }\n  }\n\n  /** Restart the game */\n  private restart(): void {\n    this.isVisible = false;\n    this.scene.physics.resume();\n    this.scene.cameras.main.fadeOut(300, 0, 0, 0);\n    this.scene.cameras.main.once('camerafadeoutcomplete', () => {\n      this.scene.scene.restart();\n    });\n  }\n\n  /** Quit to main menu */\n  private quit(): void {\n    this.isVisible = false;\n    this.scene.physics.resume();\n    this.scene.cameras.main.fadeOut(500, 0, 0, 0);\n    this.scene.cameras.main.once('camerafadeoutcomplete', () => {\n      this.scene.scene.start('Versus');\n    });\n  }\n\n  /** Check if menu is currently visible */\n  getIsVisible(): boolean {\n    return this.isVisible;\n  }\n\n  /** Destroy the menu */\n  destroy(): void {\n    this.escKey?.destroy();\n    this.upKey?.destroy();\n    this.downKey?.destroy();\n    this.wKey?.destroy();\n    this.sKey?.destroy();\n    this.enterKey?.destroy();\n    this.spaceKey?.destroy();\n    this.overlay.destroy();\n    this.container.destroy();\n  }\n}\n","/**\n * Health Bar UI\n * ==============\n * A floating health bar that follows a character and displays their HP.\n * Red theme matching BoosterBar aesthetic.\n */\n\nimport Phaser from 'phaser';\n\n/** Health bar configuration */\nconst CONFIG = {\n  /** Bar dimensions */\n  WIDTH: 120,\n  HEIGHT: 16,\n  /** Padding above character head (added to calculated position) */\n  PADDING_ABOVE_HEAD: 20,\n  /** Colors */\n  BG_COLOR: 0x1a1a2e,\n  FILL_COLOR: 0xff4444,\n  BORDER_COLOR: 0x4a4a6a,\n  GLOW_COLOR: 0xff4444,\n  /** Animation */\n  PULSE_SPEED: 600,\n  /** Corner radius */\n  BORDER_RADIUS: 8,\n};\n\nexport class HealthBar {\n  private scene: Phaser.Scene;\n  private container: Phaser.GameObjects.Container;\n  private background: Phaser.GameObjects.Graphics;\n  private fillBar: Phaser.GameObjects.Graphics;\n  private border: Phaser.GameObjects.Graphics;\n  private glowEffect: Phaser.GameObjects.Graphics;\n  private label: Phaser.GameObjects.Text;\n  private hpText: Phaser.GameObjects.Text;\n\n  private targetSprite: Phaser.Physics.Arcade.Sprite;\n  private currentProgress: number = 1;\n  private targetProgress: number = 1;\n  private maxHealth: number;\n  private currentHealth: number;\n  private headOffset: number;\n\n  constructor(\n    scene: Phaser.Scene,\n    targetSprite: Phaser.Physics.Arcade.Sprite,\n    maxHealth: number,\n    characterName: string,\n    headOffset: number = 0\n  ) {\n    this.scene = scene;\n    this.targetSprite = targetSprite;\n    this.maxHealth = maxHealth;\n    this.currentHealth = maxHealth;\n    this.headOffset = headOffset;\n\n    // Create container for all bar elements\n    this.container = scene.add.container(0, 0);\n    this.container.setDepth(1000); // Above most game elements\n\n    // Create glow effect (behind everything)\n    this.glowEffect = scene.add.graphics();\n    this.container.add(this.glowEffect);\n\n    // Create background\n    this.background = scene.add.graphics();\n    this.drawBackground();\n    this.container.add(this.background);\n\n    // Create fill bar\n    this.fillBar = scene.add.graphics();\n    this.container.add(this.fillBar);\n\n    // Create border\n    this.border = scene.add.graphics();\n    this.drawBorder();\n    this.container.add(this.border);\n\n    // Create label (character name)\n    this.label = scene.add.text(CONFIG.WIDTH / 2, -20, characterName, {\n      fontFamily: 'monospace',\n      fontSize: '12px',\n      color: '#ffffff',\n      fontStyle: 'bold',\n    });\n    this.label.setOrigin(0.5, 1);\n    this.container.add(this.label);\n\n    // Create HP text\n    this.hpText = scene.add.text(CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2, '', {\n      fontFamily: 'monospace',\n      fontSize: '10px',\n      color: '#ffffff',\n      fontStyle: 'bold',\n    });\n    this.hpText.setOrigin(0.5, 0.5);\n    this.container.add(this.hpText);\n\n    // Initial draw\n    this.updateHealth(maxHealth);\n\n    // Update loop to follow character\n    scene.events.on('update', this.update, this);\n  }\n\n  private drawBackground(): void {\n    this.background.clear();\n    this.background.fillStyle(CONFIG.BG_COLOR, 0.9);\n    this.background.fillRoundedRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT, CONFIG.BORDER_RADIUS);\n  }\n\n  private drawBorder(): void {\n    this.border.clear();\n    this.border.lineStyle(2, CONFIG.BORDER_COLOR, 1);\n    this.border.strokeRoundedRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT, CONFIG.BORDER_RADIUS);\n  }\n\n  private drawFill(progress: number): void {\n    this.fillBar.clear();\n\n    if (progress <= 0) return;\n\n    const fillWidth = Math.max(0, (CONFIG.WIDTH - 4) * progress);\n\n    // Red fill\n    this.fillBar.fillStyle(CONFIG.FILL_COLOR, 1);\n    this.fillBar.fillRoundedRect(\n      2,\n      2,\n      fillWidth,\n      CONFIG.HEIGHT - 4,\n      CONFIG.BORDER_RADIUS - 2\n    );\n\n    // Add shine effect on top\n    this.fillBar.fillStyle(0xffffff, 0.3);\n    this.fillBar.fillRoundedRect(\n      2,\n      2,\n      fillWidth,\n      (CONFIG.HEIGHT - 4) / 3,\n      { tl: CONFIG.BORDER_RADIUS - 2, tr: CONFIG.BORDER_RADIUS - 2, bl: 0, br: 0 }\n    );\n  }\n\n  private drawGlow(progress: number): void {\n    this.glowEffect.clear();\n\n    if (progress <= 0) return;\n\n    const fillWidth = (CONFIG.WIDTH - 4) * progress;\n\n    // Outer glow\n    this.glowEffect.fillStyle(CONFIG.GLOW_COLOR, 0.2);\n    this.glowEffect.fillRoundedRect(-4, -4, fillWidth + 8, CONFIG.HEIGHT + 8, CONFIG.BORDER_RADIUS + 2);\n  }\n\n  /**\n   * Update health value and redraw bar\n   */\n  updateHealth(newHealth: number): void {\n    this.currentHealth = Math.max(0, Math.min(newHealth, this.maxHealth));\n    this.targetProgress = this.currentHealth / this.maxHealth;\n\n    // Update HP text\n    this.hpText.setText(`${Math.ceil(this.currentHealth)} / ${this.maxHealth}`);\n\n    // Color change based on health percentage\n    if (this.targetProgress <= 0.3) {\n      this.hpText.setColor('#ff4444');\n      this.label.setColor('#ff4444');\n    } else if (this.targetProgress <= 0.6) {\n      this.hpText.setColor('#ffaa44');\n      this.label.setColor('#ffaa44');\n    } else {\n      this.hpText.setColor('#ffffff');\n      this.label.setColor('#ffffff');\n    }\n  }\n\n  /**\n   * Update loop - follows character and smooths progress bar\n   */\n  private update(_time: number, _delta: number): void {\n    // Follow character position - centered horizontally, above head vertically\n    // Since sprites have origin at feet (0.5, 1), top of frame is at y - displayHeight\n    // headOffset accounts for empty space at the top of the sprite frame\n    const topOfFrame = this.targetSprite.y - this.targetSprite.displayHeight;\n    const topOfHead = topOfFrame + this.headOffset;\n    this.container.setPosition(\n      this.targetSprite.x - CONFIG.WIDTH / 2,  // Center the bar horizontally\n      topOfHead - CONFIG.PADDING_ABOVE_HEAD\n    );\n\n    // Smooth progress update\n    this.currentProgress += (this.targetProgress - this.currentProgress) * 0.15;\n\n    // Update visuals\n    this.drawFill(this.currentProgress);\n    this.drawGlow(this.currentProgress);\n  }\n\n  /** Get current health */\n  getCurrentHealth(): number {\n    return this.currentHealth;\n  }\n\n  /** Get max health */\n  getMaxHealth(): number {\n    return this.maxHealth;\n  }\n\n  /** Destroy the health bar */\n  destroy(): void {\n    this.scene.events.off('update', this.update, this);\n    this.container.destroy();\n  }\n}\n","/**\n * Game Over Overlay UI\n * ====================\n * Overlay shown when a character's health reaches zero.\n * Shows \"YOU WIN\" or \"YOU LOSE\" with restart/quit options.\n * Tech-noir style matching the pause menu design.\n */\n\nimport Phaser from 'phaser';\nimport { GAME_WIDTH, GAME_HEIGHT } from '../config/GameConfig';\n\n/** Game over overlay configuration - Tech-noir style matching pause menu */\nconst CONFIG = {\n  /** Overlay color and opacity */\n  OVERLAY_COLOR: 0x000000,\n  OVERLAY_ALPHA: 0.6,\n  /** Panel styling */\n  PANEL_WIDTH: 480,\n  PANEL_HEIGHT: 350,\n  PANEL_COLOR: 0x1e293b,\n  PANEL_BORDER_COLOR: 0x64748b,\n  PANEL_BORDER_WIDTH: 2,\n  BORDER_RADIUS: 12,\n  /** Button styling */\n  BUTTON_WIDTH: 320,\n  BUTTON_HEIGHT: 60,\n  BUTTON_COLOR: 0x1e293b,\n  BUTTON_HOVER_COLOR: 0x0f2a1f,\n  BUTTON_SELECTED_COLOR: 0x4ade80, // Green accent\n  BUTTON_TEXT_COLOR: '#ffffff',\n  BUTTON_SELECTED_TEXT_COLOR: '#4ade80',\n  BUTTON_SPACING: 25,\n  /** Font */\n  FONT_FAMILY: 'Quantico',\n};\n\n/** Button data structure */\ninterface MenuButton {\n  bg: Phaser.GameObjects.Graphics;\n  text: Phaser.GameObjects.Text;\n  hitArea: Phaser.GameObjects.Rectangle;\n  callback: () => void;\n}\n\nexport class GameOverOverlay {\n  private scene: Phaser.Scene;\n  private container: Phaser.GameObjects.Container;\n  private overlay: Phaser.GameObjects.Rectangle;\n  private isVisible: boolean = false;\n\n  // Title elements (recreated on show)\n  private titleText: Phaser.GameObjects.Text | null = null;\n  private subtitleText: Phaser.GameObjects.Text | null = null;\n\n  // Keyboard navigation\n  private buttons: MenuButton[] = [];\n  private selectedIndex: number = 0;\n\n  // Input keys\n  private upKey: Phaser.Input.Keyboard.Key | null = null;\n  private downKey: Phaser.Input.Keyboard.Key | null = null;\n  private wKey: Phaser.Input.Keyboard.Key | null = null;\n  private sKey: Phaser.Input.Keyboard.Key | null = null;\n  private enterKey: Phaser.Input.Keyboard.Key | null = null;\n  private spaceKey: Phaser.Input.Keyboard.Key | null = null;\n\n  constructor(scene: Phaser.Scene) {\n    this.scene = scene;\n\n    // Create overlay (full screen darkening)\n    this.overlay = scene.add.rectangle(\n      GAME_WIDTH / 2,\n      GAME_HEIGHT / 2,\n      GAME_WIDTH,\n      GAME_HEIGHT,\n      CONFIG.OVERLAY_COLOR,\n      CONFIG.OVERLAY_ALPHA\n    );\n    this.overlay.setScrollFactor(0);\n    this.overlay.setDepth(2000);\n    this.overlay.setVisible(false);\n    this.overlay.setInteractive(); // Block clicks to game below\n\n    // Create container for menu elements\n    this.container = scene.add.container(GAME_WIDTH / 2, GAME_HEIGHT / 2);\n    this.container.setScrollFactor(0);\n    this.container.setDepth(2001);\n    this.container.setVisible(false);\n\n    this.createPanel();\n    this.createButtons();\n    this.setupInput();\n  }\n\n  private createPanel(): void {\n    // Panel background\n    const panel = this.scene.add.graphics();\n\n    const x = -CONFIG.PANEL_WIDTH / 2;\n    const y = -CONFIG.PANEL_HEIGHT / 2;\n    const width = CONFIG.PANEL_WIDTH;\n    const height = CONFIG.PANEL_HEIGHT;\n\n    // Shadow\n    panel.fillStyle(0x000000, 0.4);\n    panel.fillRoundedRect(x + 6, y + 6, width, height, CONFIG.BORDER_RADIUS);\n\n    // Main panel fill\n    panel.fillStyle(CONFIG.PANEL_COLOR, 0.92);\n    panel.fillRoundedRect(x, y, width, height, CONFIG.BORDER_RADIUS);\n\n    // Subtle border\n    panel.lineStyle(CONFIG.PANEL_BORDER_WIDTH, CONFIG.PANEL_BORDER_COLOR, 0.6);\n    panel.strokeRoundedRect(x, y, width, height, CONFIG.BORDER_RADIUS);\n\n    // Tech corner decorations\n    const cornerSize = 20;\n    const cornerOffset = 6;\n    panel.lineStyle(2, CONFIG.BUTTON_SELECTED_COLOR, 0.7);\n\n    // Top-left corner\n    panel.beginPath();\n    panel.moveTo(x - cornerOffset, y + cornerSize);\n    panel.lineTo(x - cornerOffset, y - cornerOffset);\n    panel.lineTo(x + cornerSize, y - cornerOffset);\n    panel.strokePath();\n\n    // Top-right corner\n    panel.beginPath();\n    panel.moveTo(x + width - cornerSize, y - cornerOffset);\n    panel.lineTo(x + width + cornerOffset, y - cornerOffset);\n    panel.lineTo(x + width + cornerOffset, y + cornerSize);\n    panel.strokePath();\n\n    // Bottom-left corner\n    panel.beginPath();\n    panel.moveTo(x - cornerOffset, y + height - cornerSize);\n    panel.lineTo(x - cornerOffset, y + height + cornerOffset);\n    panel.lineTo(x + cornerSize, y + height + cornerOffset);\n    panel.strokePath();\n\n    // Bottom-right corner\n    panel.beginPath();\n    panel.moveTo(x + width - cornerSize, y + height + cornerOffset);\n    panel.lineTo(x + width + cornerOffset, y + height + cornerOffset);\n    panel.lineTo(x + width + cornerOffset, y + height - cornerSize);\n    panel.strokePath();\n\n    // Subtle inner highlight at top\n    panel.lineStyle(1, 0x94a3b8, 0.2);\n    panel.lineBetween(x + 30, y + 3, x + width - 30, y + 3);\n\n    this.container.add(panel);\n  }\n\n  private createButtons(): void {\n    const buttonY = 10;\n\n    // Restart button\n    this.createButton(0, buttonY, 'RESTART', () => this.restart());\n\n    // Quit button\n    this.createButton(0, buttonY + CONFIG.BUTTON_HEIGHT + CONFIG.BUTTON_SPACING, 'QUIT TO MENU', () => this.quit());\n\n    // Navigation hint\n    const hint = this.scene.add.text(0, CONFIG.PANEL_HEIGHT / 2 - 30, 'â†‘â†“ Navigate  â€¢  ENTER Select', {\n      fontFamily: CONFIG.FONT_FAMILY,\n      fontSize: '12px',\n      color: '#64748b',\n    });\n    hint.setOrigin(0.5);\n    this.container.add(hint);\n  }\n\n  private createButton(x: number, y: number, text: string, callback: () => void): void {\n    const index = this.buttons.length;\n\n    // Button background\n    const bg = this.scene.add.graphics();\n    this.drawButton(bg, CONFIG.BUTTON_COLOR, false);\n    bg.setPosition(x, y);\n    this.container.add(bg);\n\n    // Button text\n    const buttonText = this.scene.add.text(x, y, text, {\n      fontFamily: CONFIG.FONT_FAMILY,\n      fontSize: '24px',\n      color: CONFIG.BUTTON_TEXT_COLOR,\n      stroke: '#000000',\n      strokeThickness: 3,\n    });\n    buttonText.setOrigin(0.5);\n    this.container.add(buttonText);\n\n    // Interactive zone\n    const hitArea = this.scene.add.rectangle(\n      x,\n      y,\n      CONFIG.BUTTON_WIDTH,\n      CONFIG.BUTTON_HEIGHT,\n      0xffffff,\n      0\n    );\n    hitArea.setInteractive({ useHandCursor: true });\n    this.container.add(hitArea);\n\n    // Store button reference\n    const button: MenuButton = { bg, text: buttonText, hitArea, callback };\n    this.buttons.push(button);\n\n    // Mouse hover - select this button\n    hitArea.on('pointerover', () => {\n      this.selectButton(index);\n    });\n\n    hitArea.on('pointerdown', () => {\n      buttonText.setScale(0.95);\n    });\n\n    hitArea.on('pointerup', () => {\n      buttonText.setScale(1.05);\n      callback();\n    });\n  }\n\n  private drawButton(graphics: Phaser.GameObjects.Graphics, color: number, selected: boolean = false): void {\n    graphics.clear();\n\n    const x = -CONFIG.BUTTON_WIDTH / 2;\n    const y = -CONFIG.BUTTON_HEIGHT / 2;\n    const width = CONFIG.BUTTON_WIDTH;\n    const height = CONFIG.BUTTON_HEIGHT;\n\n    // Draw glow effect for selected button\n    if (selected) {\n      for (let i = 5; i > 0; i--) {\n        graphics.lineStyle(i * 2.5, CONFIG.BUTTON_SELECTED_COLOR, 0.08);\n        graphics.strokeRoundedRect(x - i * 2, y - i * 2, width + i * 4, height + i * 4, 8);\n      }\n    }\n\n    // Button fill\n    graphics.fillStyle(color, 0.9);\n    graphics.fillRoundedRect(x, y, width, height, 8);\n\n    // Button border\n    const borderColor = selected ? 0xe0f2e9 : 0x64748b;\n    graphics.lineStyle(selected ? 3 : 2, borderColor, 1);\n    graphics.strokeRoundedRect(x, y, width, height, 8);\n\n    // Tech corner decorations\n    const cornerSize = 12;\n    const cornerOffset = 4;\n    graphics.lineStyle(2, borderColor, selected ? 1 : 0.6);\n\n    // Top-left corner\n    graphics.beginPath();\n    graphics.moveTo(x - cornerOffset, y + cornerSize);\n    graphics.lineTo(x - cornerOffset, y - cornerOffset);\n    graphics.lineTo(x + cornerSize, y - cornerOffset);\n    graphics.strokePath();\n\n    // Top-right corner\n    graphics.beginPath();\n    graphics.moveTo(x + width - cornerSize, y - cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y - cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y + cornerSize);\n    graphics.strokePath();\n\n    // Bottom-left corner\n    graphics.beginPath();\n    graphics.moveTo(x - cornerOffset, y + height - cornerSize);\n    graphics.lineTo(x - cornerOffset, y + height + cornerOffset);\n    graphics.lineTo(x + cornerSize, y + height + cornerOffset);\n    graphics.strokePath();\n\n    // Bottom-right corner\n    graphics.beginPath();\n    graphics.moveTo(x + width - cornerSize, y + height + cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y + height + cornerOffset);\n    graphics.lineTo(x + width + cornerOffset, y + height - cornerSize);\n    graphics.strokePath();\n\n    // Left accent line for selected button\n    if (selected) {\n      graphics.lineStyle(4, CONFIG.BUTTON_SELECTED_COLOR, 0.9);\n      graphics.beginPath();\n      graphics.moveTo(x, y + 12);\n      graphics.lineTo(x, y + height - 12);\n      graphics.strokePath();\n    }\n  }\n\n  private selectButton(index: number): void {\n    // Clamp index\n    if (index < 0) index = this.buttons.length - 1;\n    if (index >= this.buttons.length) index = 0;\n\n    // Update selection\n    const prevIndex = this.selectedIndex;\n    this.selectedIndex = index;\n\n    // Update previous button (deselect)\n    if (prevIndex !== index && this.buttons[prevIndex]) {\n      const prevButton = this.buttons[prevIndex];\n      this.drawButton(prevButton.bg, CONFIG.BUTTON_COLOR, false);\n      prevButton.text.setColor(CONFIG.BUTTON_TEXT_COLOR);\n      prevButton.text.setScale(1);\n    }\n\n    // Update current button (select)\n    const button = this.buttons[index];\n    this.drawButton(button.bg, CONFIG.BUTTON_HOVER_COLOR, true);\n    button.text.setColor(CONFIG.BUTTON_SELECTED_TEXT_COLOR);\n    button.text.setScale(1.05);\n    this.scene.sound.play('power-up-sfx', { volume: 0.2 });\n  }\n\n  private confirmSelection(): void {\n    const button = this.buttons[this.selectedIndex];\n    if (button) {\n      // Visual feedback\n      button.text.setScale(0.95);\n      this.scene.time.delayedCall(100, () => {\n        button.text.setScale(1.05);\n        button.callback();\n      });\n    }\n  }\n\n  private setupInput(): void {\n    const keyboard = this.scene.input.keyboard;\n    if (!keyboard) return;\n\n    // Navigation keys\n    this.upKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP);\n    this.downKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN);\n    this.wKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.sKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n\n    // Selection keys\n    this.enterKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);\n    this.spaceKey = keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // Up navigation\n    this.upKey.on('down', () => {\n      if (this.isVisible) this.selectButton(this.selectedIndex - 1);\n    });\n    this.wKey.on('down', () => {\n      if (this.isVisible) this.selectButton(this.selectedIndex - 1);\n    });\n\n    // Down navigation\n    this.downKey.on('down', () => {\n      if (this.isVisible) this.selectButton(this.selectedIndex + 1);\n    });\n    this.sKey.on('down', () => {\n      if (this.isVisible) this.selectButton(this.selectedIndex + 1);\n    });\n\n    // Confirm selection\n    this.enterKey.on('down', () => {\n      if (this.isVisible) this.confirmSelection();\n    });\n    this.spaceKey.on('down', () => {\n      if (this.isVisible) this.confirmSelection();\n    });\n  }\n\n  /** Show the game over overlay */\n  show(winner: 'player' | 'enemy'): void {\n    if (this.isVisible) return;\n    this.isVisible = true;\n\n    // Pause physics\n    this.scene.physics.pause();\n\n    // Reset selection to first button\n    this.selectedIndex = 0;\n    this.buttons.forEach((button, index) => {\n      const isSelected = index === 0;\n      this.drawButton(button.bg, isSelected ? CONFIG.BUTTON_HOVER_COLOR : CONFIG.BUTTON_COLOR, isSelected);\n      button.text.setColor(isSelected ? CONFIG.BUTTON_SELECTED_TEXT_COLOR : CONFIG.BUTTON_TEXT_COLOR);\n      button.text.setScale(isSelected ? 1.05 : 1);\n    });\n\n    // Remove old title/subtitle if exists\n    if (this.titleText) {\n      this.container.remove(this.titleText);\n      this.titleText.destroy();\n      this.titleText = null;\n    }\n    if (this.subtitleText) {\n      this.container.remove(this.subtitleText);\n      this.subtitleText.destroy();\n      this.subtitleText = null;\n    }\n\n    // Create title text based on winner\n    const titleContent = winner === 'player' ? 'VICTORY' : 'DEFEAT';\n    const titleColor = winner === 'player' ? '#4ade80' : '#f87171';\n\n    this.titleText = this.scene.add.text(0, -CONFIG.PANEL_HEIGHT / 2 + 60, titleContent, {\n      fontFamily: CONFIG.FONT_FAMILY,\n      fontSize: '48px',\n      color: titleColor,\n      stroke: '#000000',\n      strokeThickness: 4,\n    });\n    this.titleText.setOrigin(0.5);\n    this.container.add(this.titleText);\n\n    // Subtitle\n    const subtitleContent = winner === 'player' ? 'Enemy defeated!' : 'Better luck next time';\n    this.subtitleText = this.scene.add.text(0, -CONFIG.PANEL_HEIGHT / 2 + 110, subtitleContent, {\n      fontFamily: CONFIG.FONT_FAMILY,\n      fontSize: '18px',\n      color: '#94a3b8',\n    });\n    this.subtitleText.setOrigin(0.5);\n    this.container.add(this.subtitleText);\n\n    // Show elements\n    this.overlay.setVisible(true);\n    this.container.setVisible(true);\n\n    // Fade in animation\n    this.overlay.setAlpha(0);\n    this.container.setScale(0.8);\n    this.container.setAlpha(0);\n\n    this.scene.tweens.add({\n      targets: this.overlay,\n      alpha: CONFIG.OVERLAY_ALPHA,\n      duration: 200,\n      ease: 'Power2',\n    });\n\n    this.scene.tweens.add({\n      targets: this.container,\n      scale: 1,\n      alpha: 1,\n      duration: 300,\n      ease: 'Back.easeOut',\n    });\n  }\n\n  /** Hide the overlay */\n  hide(): void {\n    if (!this.isVisible) return;\n    this.isVisible = false;\n\n    // Animate out\n    this.scene.tweens.add({\n      targets: this.overlay,\n      alpha: 0,\n      duration: 200,\n      ease: 'Power2',\n    });\n\n    this.scene.tweens.add({\n      targets: this.container,\n      scale: 0.8,\n      alpha: 0,\n      duration: 200,\n      ease: 'Power2',\n      onComplete: () => {\n        this.overlay.setVisible(false);\n        this.container.setVisible(false);\n      },\n    });\n  }\n\n  /** Restart the game */\n  private restart(): void {\n    this.isVisible = false;\n    this.scene.physics.resume();\n    this.scene.cameras.main.fadeOut(300, 0, 0, 0);\n    this.scene.cameras.main.once('camerafadeoutcomplete', () => {\n      this.scene.scene.start('Game');\n    });\n  }\n\n  /** Quit to main menu */\n  private quit(): void {\n    this.isVisible = false;\n    this.scene.physics.resume();\n    this.scene.cameras.main.fadeOut(500, 0, 0, 0);\n    this.scene.cameras.main.once('camerafadeoutcomplete', () => {\n      this.scene.scene.start('Versus');\n    });\n  }\n\n  /** Check if overlay is currently visible */\n  getIsVisible(): boolean {\n    return this.isVisible;\n  }\n\n  /** Destroy the overlay */\n  destroy(): void {\n    this.upKey?.destroy();\n    this.downKey?.destroy();\n    this.wKey?.destroy();\n    this.sKey?.destroy();\n    this.enterKey?.destroy();\n    this.spaceKey?.destroy();\n    this.overlay.destroy();\n    this.container.destroy();\n  }\n}\n","/**\n * Enemy AI Controller\n * ====================\n * A Finite State Machine (FSM) based AI controller for enemy characters.\n * Controls enemy behavior including chasing, attacking, and retreating.\n */\n\nimport { Enemy } from '../entities/Enemy';\nimport { Player } from '../entities/Player';\n\n/** AI States for the finite state machine */\nexport enum AIState {\n  IDLE,      // Standing still, waiting\n  CHASE,     // Moving toward the player\n  ATTACK,    // Close enough to attack\n  RETREAT,   // Backing away (when low health or after attacking)\n}\n\n/** Configuration for AI behavior */\nconst AI_CONFIG = {\n  // Distance thresholds\n  IDLE_TO_CHASE_DISTANCE: 2000,      // Start chasing when player is within this distance\n  CHASE_TO_IDLE_DISTANCE: 600,      // Stop chasing when player is beyond this distance\n  ATTACK_DISTANCE: 120,             // Attack when within this distance\n  \n  // Distance randomization (adds unpredictability)\n  DISTANCE_VARIANCE: 30,            // +/- variance to distances\n  \n  // Timing\n  ATTACK_COOLDOWN: 800,             // ms between attacks\n  RETREAT_DURATION: 500,            // ms to retreat after attack\n  ATTACK_PAUSE_CHANCE: 0.3,         // 30% chance to pause before attacking\n  ATTACK_PAUSE_DURATION: 200,       // ms to pause before attacking\n  \n  // Behavior chances\n  RETREAT_CHANCE: 0.25,             // 25% chance to retreat after attacking\n  JUMP_WHILE_CHASING_CHANCE: 0.02,  // 2% chance per frame to jump while chasing\n  \n  // Health-based behavior\n  LOW_HEALTH_THRESHOLD: 0.3,        // 30% health is considered low\n  LOW_HEALTH_RETREAT_CHANCE: 0.4,   // 40% chance to retreat when low health\n};\n\n/**\n * EnemyAIController - Finite State Machine for enemy AI\n * \n * Controls an enemy's behavior through discrete states:\n * - IDLE: Wait until player approaches\n * - CHASE: Pursue the player\n * - ATTACK: Execute attacks when in range\n * - RETREAT: Back away strategically\n */\nexport class EnemyAIController {\n  private enemy: Enemy;\n  private player: Player;\n  \n  // FSM state\n  private currentState: AIState = AIState.IDLE;\n  private stateTimer: number = 0;\n  \n  // Attack timing\n  private attackCooldown: number = AI_CONFIG.ATTACK_COOLDOWN;\n  private lastAttackTime: number = 0;\n  \n  // State-specific timers\n  private attackPauseTimer: number = 0;\n  private isWaitingToAttack: boolean = false;\n  \n  constructor(enemy: Enemy, player: Player) {\n    this.enemy = enemy;\n    this.player = player;\n  }\n  \n  /**\n   * Main update loop - called every frame\n   * @param delta - Time elapsed since last frame in ms\n   */\n  public update(delta: number): void {\n    // Don't update if enemy is dead\n    if (this.enemy.isDead()) {\n      this.enemy.stopMoving();\n      return;\n    }\n    \n    // Don't update if player is dead\n    if (this.player.isDead()) {\n      this.enemy.stopMoving();\n      this.currentState = AIState.IDLE;\n      return;\n    }\n    \n    // Update timers\n    this.stateTimer += delta;\n    this.lastAttackTime += delta;\n    \n    if (this.attackPauseTimer > 0) {\n      this.attackPauseTimer -= delta;\n    }\n    \n    // Calculate distance to player\n    const playerX = this.player.getSprite().x;\n    const enemyX = this.enemy.getX();\n    const distance = Math.abs(playerX - enemyX);\n    \n    // Check state transitions\n    this.checkStateTransitions(distance);\n    \n    // Execute current state behavior\n    this.executeStateBehavior(distance, delta);\n  }\n  \n  /**\n   * Check and handle state transitions based on current conditions\n   */\n  private checkStateTransitions(distance: number): void {\n    // Add randomized variance to distances for unpredictability\n    const variance = (Math.random() - 0.5) * 2 * AI_CONFIG.DISTANCE_VARIANCE;\n    \n    switch (this.currentState) {\n      case AIState.IDLE:\n        // Transition to CHASE if player is within detection range\n        if (distance < AI_CONFIG.IDLE_TO_CHASE_DISTANCE + variance) {\n          this.transitionTo(AIState.CHASE);\n        }\n        break;\n        \n      case AIState.CHASE:\n        // Transition to ATTACK if close enough\n        if (distance < AI_CONFIG.ATTACK_DISTANCE + variance) {\n          this.transitionTo(AIState.ATTACK);\n        }\n        // Transition back to IDLE if player is too far\n        else if (distance > AI_CONFIG.CHASE_TO_IDLE_DISTANCE + variance) {\n          this.transitionTo(AIState.IDLE);\n        }\n        break;\n        \n      case AIState.ATTACK:\n        // If player moves out of attack range, chase them\n        if (distance > AI_CONFIG.ATTACK_DISTANCE + 20) {\n          this.transitionTo(AIState.CHASE);\n        }\n        break;\n        \n      case AIState.RETREAT:\n        // Retreat for a fixed duration, then go back to chasing\n        if (this.stateTimer >= AI_CONFIG.RETREAT_DURATION) {\n          this.transitionTo(AIState.CHASE);\n        }\n        break;\n    }\n  }\n  \n  /**\n   * Execute behavior for the current state\n   */\n  private executeStateBehavior(_distance: number, delta: number): void {\n    switch (this.currentState) {\n      case AIState.IDLE:\n        this.executeIdleBehavior();\n        break;\n        \n      case AIState.CHASE:\n        this.executeChaseBehavior(delta);\n        break;\n        \n      case AIState.ATTACK:\n        this.executeAttackBehavior();\n        break;\n        \n      case AIState.RETREAT:\n        this.executeRetreatBehavior();\n        break;\n    }\n  }\n  \n  /**\n   * IDLE state behavior - stand still and face the player\n   */\n  private executeIdleBehavior(): void {\n    this.enemy.stopMoving();\n    this.facePlayer();\n  }\n  \n  /**\n   * CHASE state behavior - move toward the player\n   */\n  private executeChaseBehavior(_delta: number): void {\n    const playerX = this.player.getSprite().x;\n    const enemyX = this.enemy.getX();\n    \n    // Move toward the player\n    if (playerX < enemyX) {\n      this.enemy.startMovingLeft();\n    } else {\n      this.enemy.startMovingRight();\n    }\n    \n    // Occasionally jump while chasing (adds unpredictability)\n    if (Math.random() < AI_CONFIG.JUMP_WHILE_CHASING_CHANCE) {\n      this.enemy.jump();\n    }\n  }\n  \n  /**\n   * ATTACK state behavior - attack the player\n   */\n  private executeAttackBehavior(): void {\n    // Always face the player before attacking\n    this.facePlayer();\n    this.enemy.stopMoving();\n    \n    // Check if we're in the middle of an attack pause\n    if (this.isWaitingToAttack) {\n      if (this.attackPauseTimer <= 0) {\n        this.isWaitingToAttack = false;\n        this.performAttack();\n      }\n      return;\n    }\n    \n    // Check if we can attack (cooldown passed and enemy can attack)\n    if (this.lastAttackTime >= this.attackCooldown && this.enemy.canAttack()) {\n      // Random chance to pause briefly before attacking\n      if (Math.random() < AI_CONFIG.ATTACK_PAUSE_CHANCE) {\n        this.isWaitingToAttack = true;\n        this.attackPauseTimer = AI_CONFIG.ATTACK_PAUSE_DURATION * (0.5 + Math.random());\n        return;\n      }\n      \n      this.performAttack();\n    }\n  }\n  \n  /**\n   * Perform an attack (randomly choose punch or sidekick)\n   */\n  private performAttack(): void {\n    // Randomly choose attack type\n    const attackSuccess = Math.random() < 0.5 \n      ? this.enemy.punch() \n      : this.enemy.sidekick();\n    \n    if (attackSuccess) {\n      this.lastAttackTime = 0;\n      \n      // After attacking, decide whether to retreat\n      const isLowHealth = this.enemy.getCurrentHealth() / this.enemy.getMaxHealth() < AI_CONFIG.LOW_HEALTH_THRESHOLD;\n      const retreatChance = isLowHealth \n        ? AI_CONFIG.LOW_HEALTH_RETREAT_CHANCE \n        : AI_CONFIG.RETREAT_CHANCE;\n      \n      if (Math.random() < retreatChance) {\n        // Small delay before retreating (let attack animation play)\n        setTimeout(() => {\n          if (this.currentState === AIState.ATTACK) {\n            this.transitionTo(AIState.RETREAT);\n          }\n        }, 200);\n      } else {\n        // Go back to chasing\n        setTimeout(() => {\n          if (this.currentState === AIState.ATTACK) {\n            this.transitionTo(AIState.CHASE);\n          }\n        }, 100);\n      }\n    }\n  }\n  \n  /**\n   * RETREAT state behavior - move away from the player\n   */\n  private executeRetreatBehavior(): void {\n    const playerX = this.player.getSprite().x;\n    const enemyX = this.enemy.getX();\n    \n    // Move away from the player\n    if (playerX < enemyX) {\n      this.enemy.startMovingRight();\n    } else {\n      this.enemy.startMovingLeft();\n    }\n    \n    // Keep facing the player while retreating\n    this.facePlayer();\n  }\n  \n  /**\n   * Transition to a new state\n   */\n  private transitionTo(newState: AIState): void {\n    // Exit current state\n    this.enemy.stopMoving();\n    this.isWaitingToAttack = false;\n    \n    // Enter new state\n    this.currentState = newState;\n    this.stateTimer = 0;\n  }\n  \n  /**\n   * Make the enemy face toward the player\n   */\n  private facePlayer(): void {\n    const playerX = this.player.getSprite().x;\n    const enemyX = this.enemy.getX();\n    \n    // Face right if player is to the right, left otherwise\n    this.enemy.setFacing(playerX > enemyX);\n  }\n  \n  /**\n   * Get the current AI state (for debugging/UI)\n   */\n  public getCurrentState(): AIState {\n    return this.currentState;\n  }\n  \n  /**\n   * Get state name as string (for debugging)\n   */\n  public getStateName(): string {\n    switch (this.currentState) {\n      case AIState.IDLE: return 'IDLE';\n      case AIState.CHASE: return 'CHASE';\n      case AIState.ATTACK: return 'ATTACK';\n      case AIState.RETREAT: return 'RETREAT';\n      default: return 'UNKNOWN';\n    }\n  }\n  \n  /**\n   * Force a specific state (useful for testing or scripted sequences)\n   */\n  public forceState(state: AIState): void {\n    this.transitionTo(state);\n  }\n  \n  /**\n   * Set attack cooldown (allows difficulty adjustment)\n   */\n  public setAttackCooldown(cooldownMs: number): void {\n    this.attackCooldown = cooldownMs;\n  }\n}\n\nexport default EnemyAIController;\n","/**\n * Game Scene\n * ===========\n * Main gameplay scene - creates the world, player, and handles game logic.\n */\n\nimport Phaser from 'phaser';\nimport { GAME_WIDTH, GAME_HEIGHT } from '../config/GameConfig.ts';\nimport { Player } from '../entities/Player.ts';\nimport { Enemy } from '../entities/Enemy.ts';\nimport { PowerBooster } from '../entities/PowerBooster.ts';\nimport { InputManager } from '../systems/InputManager.ts';\nimport { BoosterBar } from '../ui/BoosterBar.ts';\nimport { PauseMenu } from '../ui/PauseMenu.ts';\nimport { HealthBar } from '../ui/HealthBar.ts';\nimport { GameOverOverlay } from '../ui/GameOverOverlay.ts';\nimport { EnemyAIController } from '../ai/EnemyAIController.ts';\n// import { getEnemyAIAction, GameState, CollisionObject } from '../ai/ai-access.ts';\n\n/** Height of the ground collision floor in pixels */\nconst GROUND_HEIGHT = 130;\n\nexport class GameScene extends Phaser.Scene {\n  private player!: Player;\n  private inputManager!: InputManager;\n  private ground!: Phaser.Physics.Arcade.StaticGroup;\n  private powerBoosters: PowerBooster[] = [];\n  private enemies: Enemy[] = [];\n  private boosterBar!: BoosterBar;\n  private pauseMenu!: PauseMenu;\n  private gameOverOverlay!: GameOverOverlay;\n  private playerHealthBar!: HealthBar;\n  private enemyHealthBars: Map<Enemy, HealthBar> = new Map();\n  private gameEnded: boolean = false;\n  private debugUpdateHandler: (() => void) | null = null;\n\n  // Traditional AI controllers (FSM-based)\n  private enemyAIControllers: EnemyAIController[] = [];\n\n  // LLM AI control system (deprecated - using traditional AI now)\n  // private aiUpdateInterval: number = 10; // ms between AI decisions\n  // private lastAIUpdate: number = 0;\n  // private isAIUpdating: boolean = false; // Prevent overlapping AI calls\n\n  constructor() {\n    super({ key: 'Game' });\n  }\n\n  private createBackground(): void {\n    // Add background image anchored at left edge, vertically centered\n    const bg = this.add.image(0, GAME_HEIGHT / 2, 'bg-overgrown-city-sunset');\n    bg.setOrigin(0, 0.5);\n\n    // Scale to cover full height while maintaining aspect ratio\n    // This makes the width extend beyond GAME_WIDTH\n    const scale = GAME_HEIGHT / bg.height;\n    bg.setScale(scale);\n\n    // Ensure background is behind all other elements\n    bg.setDepth(-100);\n\n    // Add slight blur effect for depth-of-field look\n    bg.preFX?.addBlur(0, 2, 2, 0.3);\n  }\n\n  create(): void {\n    console.log('[GameScene] Creating game world...');\n   \n\n    // Reset game state flags (CRITICAL for scene restart)\n    this.gameEnded = false;\n\n    // Reset update counter for logging (in case scene instance is reused)\n    this.updateCounter = 0;\n\n    this.createBackground();\n    console.log('[GameScene] Background created');\n\n    this.inputManager = new InputManager(this);\n    console.log('[GameScene] InputManager created');\n\n    this.createPlatforms();\n    console.log('[GameScene] Platforms created');\n\n    this.createFloorVisual();\n    console.log('[GameScene] Floor visual created');\n\n    this.createPlayer();\n    console.log('[GameScene] Player created');\n\n    this.createBoosterBar();\n    console.log('[GameScene] BoosterBar created');\n\n    this.createPowerBoosters();\n    console.log('[GameScene] PowerBoosters created');\n\n    this.createEnemies();\n    console.log('[GameScene] Enemies created');\n\n    // Set up counter-dodge system: provide player with warning checks and timing info\n    this.player.setEnemyWarningChecker(\n      () => this.isAnyEnemyShowingWarning(),\n      () => this.getTimeUntilEnemyAttack()\n    );\n    console.log('[GameScene] Counter-dodge system linked');\n\n    this.setupCollisions();\n    console.log('[GameScene] Collisions set up');\n\n    this.setupCamera();\n    console.log('[GameScene] Camera set up');\n\n    this.createDebugInfo();\n    console.log('[GameScene] Debug info created');\n\n    this.createPauseMenu();\n    console.log('[GameScene] PauseMenu created');\n\n    this.createGameOverOverlay();\n    console.log('[GameScene] GameOverOverlay created');\n\n    this.createHealthBars();\n    console.log('[GameScene] HealthBars created');\n\n    // Countdown before match starts (3, 2, 1) - movement gated by registry 'matchStarted'\n    this.registry.set('matchStarted', false);\n    this.createCountdown();\n\n    // Register shutdown handler to clean up event listeners\n    this.events.once('shutdown', this.shutdown, this);\n  }\n\n  private createCountdown(): void {\n    const countdownY = 140;\n    const countdownText = this.add.text(GAME_WIDTH / 2, countdownY, '3', {\n      fontFamily: 'Quantico, Russo One, Arial',\n      fontSize: '120px',\n      fontStyle: 'bold',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 8,\n    });\n    countdownText.setOrigin(0.5, 0.5);\n    countdownText.setDepth(500);\n\n    const showNumber = (n: number) => {\n      countdownText.setText(String(n));\n      countdownText.setScale(0.5);\n      this.tweens.add({\n        targets: countdownText,\n        scale: 1.2,\n        duration: 250,\n        ease: 'Back.easeOut',\n        onComplete: () => countdownText.setScale(1),\n      });\n    };\n\n    this.time.delayedCall(0, () => showNumber(3));\n    this.time.delayedCall(1000, () => showNumber(2));\n    this.time.delayedCall(2000, () => showNumber(1));\n    this.time.delayedCall(3000, () => {\n      countdownText.destroy();\n      this.registry.set('matchStarted', true);\n    });\n  }\n\n  private createPauseMenu(): void {\n    // Pass a callback to check if pausing is allowed (not when game is over)\n    this.pauseMenu = new PauseMenu(this, () => !this.gameEnded);\n  }\n\n  private createGameOverOverlay(): void {\n    this.gameOverOverlay = new GameOverOverlay(this);\n  }\n\n  private createHealthBars(): void {\n    // Head offset accounts for empty space at top of sprite frames (in display pixels)\n    // Player: body starts at y=170 in 400px frame, head ~50px above body = 120px empty * 0.65 scale\n    // Enemy: similar proportions at 0.8 scale\n    const playerHeadOffset = 117;  // Display pixels from top of frame to actual head\n    const enemyHeadOffset = 110;   // Display pixels from top of frame to actual head\n\n    // Create health bar for player\n    this.playerHealthBar = new HealthBar(\n      this,\n      this.player.getSprite(),\n      this.player.getMaxHealth(),\n      'APE',\n      playerHeadOffset\n    );\n    this.player.setHealthBar(this.playerHealthBar);\n\n    // Create health bars for enemies\n    this.enemies.forEach((enemy) => {\n      const enemyHealthBar = new HealthBar(\n        this,\n        enemy.getSprite(),\n        enemy.getMaxHealth(),\n        'ENEMY',\n        enemyHeadOffset\n      );\n      enemy.setHealthBar(enemyHealthBar);\n      this.enemyHealthBars.set(enemy, enemyHealthBar);\n    });\n  }\n\n  private createBoosterBar(): void {\n    this.boosterBar = new BoosterBar(this);\n  }\n\n  private createPlatforms(): void {\n    this.ground = this.physics.add.staticGroup();\n\n    // Create ground texture\n    const groundGfx = this.add.graphics();\n    groundGfx.fillStyle(0x4a5568, 1);\n    groundGfx.fillRect(0, 0, GAME_WIDTH, GROUND_HEIGHT);\n    groundGfx.generateTexture('ground-texture', GAME_WIDTH, GROUND_HEIGHT);\n    groundGfx.destroy();\n\n    // Create platform texture (narrower than visual so overgrown platform art covers it)\n    const PLATFORM_COLLISION_WIDTH = 260;\n    const platGfx = this.add.graphics();\n    platGfx.fillStyle(0x6b7280, 1);\n    platGfx.fillRect(0, 0, PLATFORM_COLLISION_WIDTH, 20);\n    platGfx.generateTexture('platform-texture', PLATFORM_COLLISION_WIDTH, 20);\n    platGfx.destroy();\n\n\n    // Ground - position center lower so collision top is hidden under overgrown ground visual\n    const GROUND_OFFSET_Y = 28;\n    const ground = this.ground.create(GAME_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT / 2 + GROUND_OFFSET_Y, 'ground-texture') as Phaser.Physics.Arcade.Sprite;\n    ground.refreshBody();\n\n    // Floating platforms (offset down so collision + visual move together)\n    const FLOATING_PLATFORM_OFFSET_Y = 24;\n    this.createPlatform(200, GAME_HEIGHT - 500 + FLOATING_PLATFORM_OFFSET_Y);\n    this.createPlatform(600, GAME_HEIGHT - 325 + FLOATING_PLATFORM_OFFSET_Y);\n    this.createPlatform(1100, GAME_HEIGHT - 450 + FLOATING_PLATFORM_OFFSET_Y);\n  }\n\n  private createPlatform(x: number, y: number): void {\n    // Offset to raise collision box relative to visual (positive = collision higher)\n    const collisionOffset = 20;\n\n    // Create collision platform at offset position (higher than visual)\n    const platform = this.ground.create(x, y - collisionOffset, 'platform-texture') as Phaser.Physics.Arcade.Sprite;\n    platform.refreshBody();\n\n    // Add visual platform image (overgrown style); visual is wider than collision so it covers the box\n    const visualOffsetY = 26;\n    const platformImage = this.add.image(x, y + visualOffsetY, 'floating-platform');\n    const visualWidth = 350;\n    const scale = visualWidth / platformImage.width;\n    platformImage.setScale(scale);\n    // Anchor from bottom-center so the platform surface aligns with collision\n    platformImage.setOrigin(0.5, 0.95);\n    // Depth between background and player\n    platformImage.setDepth(0);\n  }\n\n  private createFloorVisual(): void {\n    // Add the visual floor image on top of the collision floor\n    // Position at bottom of screen, anchor from bottom-left\n    const floorImage = this.add.image(0, GAME_HEIGHT, 'floor-overgrown-city');\n    floorImage.setOrigin(0, 1); // Anchor at bottom-left\n\n    // Scale to cover the full game width while maintaining aspect ratio\n    const scale = GAME_WIDTH / floorImage.width;\n    floorImage.setScale(scale);\n\n    // Set depth between background (-100) and player (10)\n    floorImage.setDepth(0);\n  }\n\n  private createPowerBoosters(): void {\n    // Spawn power boosters at strategic locations\n    // On the ground area\n    this.powerBoosters.push(new PowerBooster(this, 400, GAME_HEIGHT - GROUND_HEIGHT - 50));\n\n    // Near the floating platforms\n    this.powerBoosters.push(new PowerBooster(this, 600, GAME_HEIGHT - 400));\n\n    // On top of a platform\n    this.powerBoosters.push(new PowerBooster(this, 1100, GAME_HEIGHT - 530));\n  }\n\n  private createEnemies(): void {\n    // Spawn an enemy at the right edge of the canvas, facing left (toward player spawn)\n    const enemy = new Enemy(this, GAME_WIDTH - 100, GAME_HEIGHT - GROUND_HEIGHT, this.inputManager);\n    enemy.getSprite().setDepth(10); // Same depth as player\n    this.enemies.push(enemy);\n\n    // Create traditional AI controller for the enemy\n    const aiController = new EnemyAIController(enemy, this.player);\n    this.enemyAIControllers.push(aiController);\n  }\n\n  private createPlayer(): void {\n    const startX = 100;\n    // Spawn at ground level (ground top is at GAME_HEIGHT - GROUND_HEIGHT)\n    // With origin (0.5, 1), this y is where the feet will be\n    const startY = GAME_HEIGHT - GROUND_HEIGHT;\n    this.player = new Player(this, startX, startY, this.inputManager);\n\n    // Set player depth higher than floor visual\n    this.player.getSprite().setDepth(10);\n  }\n\n  private setupCollisions(): void {\n    // Player collides with ground/platforms\n    this.physics.add.collider(this.player.getSprite(), this.ground);\n\n    // Enemies collide with ground/platforms\n    this.enemies.forEach((enemy) => {\n      this.physics.add.collider(enemy.getSprite(), this.ground);\n    });\n\n    // Player overlaps with power boosters (pickup)\n    this.powerBoosters.forEach((booster) => {\n      this.physics.add.overlap(\n        this.player.getSprite(),\n        booster.getSprite(),\n        () => {\n          if (!booster.isAlreadyCollected()) {\n            booster.collect(this.player.getSprite(), this.boosterBar);\n          }\n        },\n        undefined,\n        this\n      );\n    });\n  }\n\n  private setupCamera(): void {\n    this.cameras.main.setBounds(0, 0, GAME_WIDTH, GAME_HEIGHT);\n    this.cameras.main.startFollow(this.player.getSprite(), true, 0.1, 0.1);\n  }\n\n  private createDebugInfo(): void {\n    console.log('[GameScene] Creating debug info');\n    const debugText = this.add.text(10, 10, '', {\n      fontFamily: 'monospace',\n      fontSize: '14px',\n      color: '#00ff00',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 5 },\n    });\n    debugText.setScrollFactor(0);\n    debugText.setDepth(1000);\n\n    // Store the handler so we can remove it in shutdown()\n    this.debugUpdateHandler = () => {\n      const sprite = this.player.getSprite();\n      const body = sprite.body as Phaser.Physics.Arcade.Body;\n      debugText.setText([\n        `FPS: ${Math.round(this.game.loop.actualFps)}`,\n        `Player: (${Math.round(sprite.x)}, ${Math.round(sprite.y)})`,\n        `Velocity: (${Math.round(body?.velocity.x ?? 0)}, ${Math.round(body?.velocity.y ?? 0)})`,\n        `On Ground: ${body?.blocked.down ?? false}`,\n      ].join('\\n'));\n    };\n    this.events.on('update', this.debugUpdateHandler);\n  }\n\n  private updateCounter = 0;\n  \n  update(): void {\n    try {\n      // Log first few updates to verify update loop is running\n      if (this.updateCounter < 3) {\n       \n        this.updateCounter++;\n      }\n      \n      // Don't update if game is ended\n      if (this.gameEnded) {\n        return;\n      }\n\n      // Don't update if paused\n      if (this.pauseMenu?.getIsVisible()) {\n        return;\n      }\n\n      this.player?.update();\n    } catch (error: any) {\n      throw error;\n    }\n  \n\n    // Update all enemies\n    this.enemies.forEach((enemy) => {\n      enemy.update();\n    });\n\n    // Update AI controllers (traditional FSM-based AI)\n    const delta = this.game.loop.delta;\n    this.enemyAIControllers.forEach((controller, index) => {\n      if (!this.enemies[index].isDead()) {\n        controller.update(delta);\n      }\n    });\n\n    // LLM-based AI (deprecated - using traditional AI now)\n    // this.updateEnemyAI();\n\n    // Check for combat hits\n    this.checkPlayerAttacks();\n    this.checkEnemyAttacks();\n\n    // Check for death\n    this.checkDeath();\n  }\n\n  /**\n   * Check if player attacks are hitting enemies\n   */\n  private checkPlayerAttacks(): void {\n    // Get player's attack hitbox\n    const attackHitbox = this.player.getAttackHitbox();\n    if (!attackHitbox) {\n      return; // Not attacking or not in hit frame\n    }\n\n    // Check each enemy\n    this.enemies.forEach((enemy) => {\n      // Skip if enemy is dead or invincible\n      if (enemy.isDead() || enemy.getIsInvincible()) {\n        return;\n      }\n\n      // Get enemy sprite bounds\n      const enemySprite = enemy.getSprite();\n      const enemyBody = enemySprite.body as Phaser.Physics.Arcade.Body;\n\n      // Calculate enemy bounds from body\n      const enemyLeft = enemySprite.x - enemyBody.width / 2;\n      const enemyRight = enemySprite.x + enemyBody.width / 2;\n      const enemyTop = enemySprite.y - enemyBody.height / 2;\n      const enemyBottom = enemySprite.y + enemyBody.height / 2;\n\n      // Check if attack hitbox overlaps with enemy bounds\n      const hitboxRight = attackHitbox.x + attackHitbox.width;\n      const hitboxBottom = attackHitbox.y + attackHitbox.height;\n\n      if (attackHitbox.x < enemyRight &&\n        hitboxRight > enemyLeft &&\n        attackHitbox.y < enemyBottom &&\n        hitboxBottom > enemyTop) {\n        // Deal damage, passing attack type for appropriate reaction animation\n        const damage = this.player.getAttackDamage();\n        const attackType = this.player.getAttackType();\n        enemy.takeDamage(damage, this.player.getSprite().x, attackType ?? undefined);\n      }\n    });\n  }\n\n  /**\n   * Check if enemy attacks are hitting the player\n   */\n  private checkEnemyAttacks(): void {\n    // Skip if player is dead or invincible\n    if (this.player.isDead() || this.player.getIsInvincible()) {\n      return;\n    }\n\n    // Check each enemy\n    this.enemies.forEach((enemy) => {\n      // Skip if enemy is dead\n      if (enemy.isDead()) {\n        return;\n      }\n\n      // Get enemy's attack hitbox\n      const attackHitbox = enemy.getAttackHitbox();\n      if (!attackHitbox) {\n        return; // Not attacking or not in hit frame\n      }\n\n      // Get player sprite bounds\n      const playerSprite = this.player.getSprite();\n      const playerBody = playerSprite.body as Phaser.Physics.Arcade.Body;\n\n      // Calculate player bounds from body\n      const playerLeft = playerSprite.x - playerBody.width / 2;\n      const playerRight = playerSprite.x + playerBody.width / 2;\n      const playerTop = playerSprite.y - playerBody.height / 2;\n      const playerBottom = playerSprite.y + playerBody.height / 2;\n\n      // Check if attack hitbox overlaps with player bounds\n      const hitboxRight = attackHitbox.x + attackHitbox.width;\n      const hitboxBottom = attackHitbox.y + attackHitbox.height;\n\n      if (attackHitbox.x < playerRight &&\n        hitboxRight > playerLeft &&\n        attackHitbox.y < playerBottom &&\n        hitboxBottom > playerTop) {\n        // Deal damage\n        const damage = enemy.getAttackDamage();\n        this.player.takeDamage(damage, enemy.getSprite().x);\n      }\n    });\n  }\n\n  /**\n   * Check if any character has died and trigger game over\n   */\n  private checkDeath(): void {\n    if (this.gameEnded) {\n      return;\n    }\n\n    // Check if player is dead\n    if (this.player.isDead()) {\n      this.gameEnded = true;\n      this.physics.pause();\n      this.gameOverOverlay.show('enemy');\n      return;\n    }\n\n    // Check if all enemies are dead\n    const allEnemiesDead = this.enemies.every((enemy) => enemy.isDead());\n    if (allEnemiesDead && this.enemies.length > 0) {\n      this.gameEnded = true;\n      this.physics.pause();\n      this.gameOverOverlay.show('player');\n      return;\n    }\n  }\n\n  /**\n   * Check if any alive enemy is currently showing an attack warning\n   * Used by the player's counter-dodge system to determine if dodge was timed correctly\n   */\n  private isAnyEnemyShowingWarning(): boolean {\n    return this.enemies.some((enemy) => !enemy.isDead() && enemy.isShowingWarning());\n  }\n\n  /**\n   * Get the time until the next enemy attack executes (in ms)\n   * Returns 0 if no enemy is showing warning\n   * Used by player's counter-dodge to sync dodge animation with attack\n   */\n  private getTimeUntilEnemyAttack(): number {\n    let minTime = Infinity;\n    \n    for (const enemy of this.enemies) {\n      if (!enemy.isDead() && enemy.isShowingWarning()) {\n        const timeUntil = enemy.getTimeUntilAttack();\n        if (timeUntil < minTime) {\n          minTime = timeUntil;\n        }\n      }\n    }\n    \n    return minTime === Infinity ? 0 : minTime;\n  }\n\n  // ============================================================================\n  // LLM-based AI methods (deprecated - using traditional FSM AI now)\n  // ============================================================================\n  \n  // /**\n  //  * Collect all collision objects (platforms, ground) for AI decision making\n  //  */\n  // private getCollisionObjects(): CollisionObject[] {\n  //   const objects: CollisionObject[] = [];\n\n  //   this.ground.getChildren().forEach((child) => {\n  //     const platform = child as Phaser.Physics.Arcade.Sprite;\n  //     const body = platform.body as Phaser.Physics.Arcade.StaticBody;\n      \n  //     // Determine type based on size (ground is wider)\n  //     const isGround = body.width >= GAME_WIDTH * 0.5;\n      \n  //     objects.push({\n  //       x: platform.x,\n  //       y: platform.y,\n  //       width: body.width,\n  //       height: body.height,\n  //       type: isGround ? 'floor' : 'platform',\n  //     });\n  //   });\n\n  //   return objects;\n  // }\n\n  // /**\n  //  * Build the current game state for AI decision making\n  //  */\n  // private getGameState(enemy: Enemy): GameState {\n  //   const playerSprite = this.player.getSprite();\n  //   const enemySprite = enemy.getSprite();\n    \n  //   return {\n  //     // Enemy state\n  //     enemyX: enemy.getX(),\n  //     enemyY: enemy.getY(),\n  //     enemyHeight: enemySprite.displayHeight,\n  //     enemyHealth: enemy.getCurrentHealth(),\n  //     enemyMaxHealth: enemy.getMaxHealth(),\n  //     enemyFacingRight: enemy.isFacingRight(),\n  //     canAttack: enemy.canAttack(),\n  //     canJump: enemy.canJump(),\n      \n  //     // Player state\n  //     playerX: playerSprite.x,\n  //     playerY: playerSprite.y,\n  //     playerHealth: this.player.getCurrentHealth(),\n  //     playerMaxHealth: this.player.getMaxHealth(),\n      \n  //     // Spatial relationship\n  //     distance: Math.abs(enemy.getX() - playerSprite.x),\n      \n  //     // World objects\n  //     collisionObjects: this.getCollisionObjects(),\n  //   };\n  // }\n\n  // /**\n  //  * Update enemy AI - called periodically (not every frame)\n  //  */\n  // private async updateEnemyAI(): Promise<void> {\n  //   // Prevent overlapping AI calls\n  //   if (this.isAIUpdating) {\n  //     return;\n  //   }\n\n  //   const now = this.time.now;\n    \n  //   // Check if enough time has passed since last AI update\n  //   if (now - this.lastAIUpdate < this.aiUpdateInterval) {\n  //     return;\n  //   }\n\n  //   this.lastAIUpdate = now;\n  //   this.isAIUpdating = true;\n\n  //   try {\n  //     // Update AI for each enemy\n  //     for (const enemy of this.enemies) {\n  //       // Skip dead enemies\n  //       if (enemy.isDead()) {\n  //         continue;\n  //       }\n\n  //       const gameState = this.getGameState(enemy);\n  //       const { action, params } = await getEnemyAIAction(gameState);\n\n  //       // Log AI decision\n  //       console.log(`[AI] Decision: ${action}`, params ? `params: ${JSON.stringify(params)}` : '');\n\n  //       // Execute the action\n  //       switch (action) {\n  //         case 'punch':\n  //           enemy.punch();\n  //           break;\n  //         case 'sidekick':\n  //           enemy.sidekick();\n  //           break;\n  //         case 'jump':\n  //           enemy.jump();\n  //           break;\n  //         case 'moveLeft':\n  //           if (params?.pixels) {\n  //             enemy.moveLeftBy(params.pixels);\n  //           } else {\n  //             enemy.startMovingLeft();\n  //           }\n  //           break;\n  //         case 'moveRight':\n  //           if (params?.pixels) {\n  //             enemy.moveRightBy(params.pixels);\n  //           } else {\n  //             enemy.startMovingRight();\n  //           }\n  //           break;\n  //         case 'stopMoving':\n  //           enemy.stopMoving();\n  //           break;\n  //         case 'wait':\n  //           // Do nothing\n  //           break;\n  //       }\n  //     }\n  //   } catch (error) {\n  //     console.error('AI update error:', error);\n  //   } finally {\n  //     this.isAIUpdating = false;\n  //   }\n  // }\n\n  /**\n   * Clean up resources when scene is shutdown\n   * This prevents lingering event listeners from interfering with scene restarts\n   */\n  shutdown(): void {\n    console.log('[GameScene] Shutting down...');\n    \n    // CRITICAL: Remove the debug update handler to prevent it from running after scene restart\n    if (this.debugUpdateHandler) {\n      this.events.off('update', this.debugUpdateHandler);\n      this.debugUpdateHandler = null;\n    }\n    \n    // Destroy UI components with their event listeners\n    this.pauseMenu?.destroy();\n    this.gameOverOverlay?.destroy();\n    \n    // Clear health bars\n    this.playerHealthBar?.destroy();\n    this.enemyHealthBars.forEach((healthBar) => healthBar.destroy());\n    this.enemyHealthBars.clear();\n    \n    // Reset arrays to prevent stale references\n    this.powerBoosters = [];\n    this.enemies = [];\n    this.enemyAIControllers = [];\n  }\n}\n","/**\n * Versus Scene\n * =============\n * Shows the versus screen (APE vs Blockhead) after pressing Fight, then starts the game.\n */\n\nimport Phaser from 'phaser';\nimport { GAME_WIDTH, GAME_HEIGHT } from '../config/GameConfig';\n\nconst VERSUS_DURATION_MS = 2500;\n\nexport class VersusScene extends Phaser.Scene {\n  constructor() {\n    super({ key: 'Versus' });\n  }\n\n  create(): void {\n    const bg = this.add.image(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'versus-bg');\n    bg.setDisplaySize(GAME_WIDTH, GAME_HEIGHT);\n    bg.setDepth(0);\n\n    this.cameras.main.fadeIn(300);\n\n    this.time.delayedCall(VERSUS_DURATION_MS, () => {\n      this.cameras.main.fadeOut(400, 0, 0, 0);\n      this.cameras.main.once('camerafadeoutcomplete', () => {\n        this.scene.start('Game');\n      });\n    });\n  }\n}\n","/**\n * Story Scene\n * ===========\n * Placeholder scene for story content.\n */\n\nimport Phaser from 'phaser';\nimport { GAME_WIDTH, GAME_HEIGHT } from '../config/GameConfig';\n\nexport class StoryScene extends Phaser.Scene {\n  constructor() {\n    super({ key: 'Story' });\n  }\n\n  create(): void {\n    console.log('[StoryScene] Showing story placeholder');\n\n    // Create background (same as menu)\n    this.createBackground();\n\n    // Continue menu music if playing\n    const existingMusic = this.sound.get('menu-music');\n    if (existingMusic && existingMusic.isPlaying) {\n      // Music continues from menu\n    }\n\n    // Title\n    const title = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 100, 'Story', {\n      fontFamily: 'Russo One',\n      fontSize: '72px',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 8,\n    });\n    title.setOrigin(0.5);\n\n    // Coming soon message\n    const comingSoon = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 50, 'Coming Soon', {\n      fontFamily: 'Russo One',\n      fontSize: '36px',\n      color: '#cccccc',\n      stroke: '#000000',\n      strokeThickness: 4,\n    });\n    comingSoon.setOrigin(0.5);\n\n    // Instructions\n    const instructions = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT - 100, 'Press ESC to return to menu', {\n      fontFamily: 'Arial',\n      fontSize: '24px',\n      color: '#888888',\n    });\n    instructions.setOrigin(0.5);\n\n    // ESC to return to menu\n    this.input.keyboard?.on('keydown-ESC', () => {\n      this.scene.start('Menu');\n    });\n  }\n\n  private createBackground(): void {\n    // Add background image\n    const bg = this.add.image(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'bg-server-lab');\n    bg.setDisplaySize(GAME_WIDTH, GAME_HEIGHT);\n    bg.setDepth(-100);\n\n    // Add dim overlay\n    const overlay = this.add.graphics();\n    overlay.fillStyle(0x000000, 0.5);\n    overlay.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n    overlay.setDepth(-99);\n  }\n}\n","/**\n * Credits Scene\n * =============\n * Placeholder scene for credits content.\n */\n\nimport Phaser from 'phaser';\nimport { GAME_WIDTH, GAME_HEIGHT } from '../config/GameConfig';\n\nexport class CreditsScene extends Phaser.Scene {\n  constructor() {\n    super({ key: 'Credits' });\n  }\n\n  create(): void {\n    console.log('[CreditsScene] Showing credits placeholder');\n\n    // Create background (same as menu)\n    this.createBackground();\n\n    // Continue menu music if playing\n    const existingMusic = this.sound.get('menu-music');\n    if (existingMusic && existingMusic.isPlaying) {\n      // Music continues from menu\n    }\n\n    // Title\n    const title = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 100, 'Credits', {\n      fontFamily: 'Russo One',\n      fontSize: '72px',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 8,\n    });\n    title.setOrigin(0.5);\n\n    // Coming soon message\n    const comingSoon = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 50, 'Coming Soon', {\n      fontFamily: 'Russo One',\n      fontSize: '36px',\n      color: '#cccccc',\n      stroke: '#000000',\n      strokeThickness: 4,\n    });\n    comingSoon.setOrigin(0.5);\n\n    // Instructions\n    const instructions = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT - 100, 'Press ESC to return to menu', {\n      fontFamily: 'Arial',\n      fontSize: '24px',\n      color: '#888888',\n    });\n    instructions.setOrigin(0.5);\n\n    // ESC to return to menu\n    this.input.keyboard?.on('keydown-ESC', () => {\n      this.scene.start('Menu');\n    });\n  }\n\n  private createBackground(): void {\n    // Add background image\n    const bg = this.add.image(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'bg-server-lab');\n    bg.setDisplaySize(GAME_WIDTH, GAME_HEIGHT);\n    bg.setDepth(-100);\n\n    // Add dim overlay\n    const overlay = this.add.graphics();\n    overlay.fillStyle(0x000000, 0.5);\n    overlay.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n    overlay.setDepth(-99);\n  }\n}\n","/**\n * Game Configuration\n * ===================\n * Defines how Phaser should set up the game - resolution, physics, rendering, etc.\n */\n\nimport Phaser from 'phaser';\nimport { BootScene } from '../scenes/BootScene.ts';\nimport { PreloadScene } from '../scenes/PreloadScene.ts';\nimport { MenuScene } from '../scenes/MenuScene.ts';\nimport { GameScene } from '../scenes/GameScene.ts';\nimport { VersusScene } from '../scenes/VersusScene.ts';\nimport { StoryScene } from '../scenes/StoryScene.ts';\nimport { CreditsScene } from '../scenes/CreditsScene.ts';\n\n/** Game dimensions - 16:9 HD resolution */\nexport const GAME_WIDTH = 1280;\nexport const GAME_HEIGHT = 720;\n\n/** Main Phaser configuration object */\nexport const gameConfig: Phaser.Types.Core.GameConfig = {\n  // AUTO = try WebGL first, fallback to Canvas\n  type: Phaser.AUTO,\n\n  // HTML element to inject canvas into\n  parent: 'game-container',\n\n  // Internal game resolution\n  width: GAME_WIDTH,\n  height: GAME_HEIGHT,\n\n  // Background color (matches server lab image edges)\n  backgroundColor: '#0d1117',\n\n  // Scaling behavior\n  scale: {\n    mode: Phaser.Scale.FIT,\n    autoCenter: Phaser.Scale.CENTER_BOTH,\n  },\n\n  // Physics configuration - Arcade is simple and fast\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { x: 0, y: 800 },\n      debug: false,\n      debugShowBody: true,\n      debugBodyColor: 0xff0000, // Red color for collision boxes\n    },\n  },\n\n  // Scene order - first runs first\n  scene: [BootScene, PreloadScene, MenuScene, VersusScene, GameScene, StoryScene, CreditsScene],\n\n  // Rendering settings for detailed artwork (not pixel art)\n  render: {\n    pixelArt: false,        // Use smooth filtering for detailed sprites\n    antialias: true,        // Enable antialiasing for smoother edges\n    roundPixels: false,     // Allow sub-pixel rendering for smooth movement\n  },\n};\n","/**\n * Main Entry Point\n * =================\n * Creates the Phaser.Game instance using our configuration.\n * This kicks off the entire game lifecycle.\n */\n\nimport Phaser from 'phaser';\nimport { gameConfig } from './config/GameConfig.ts';\nimport './styles/fonts.css';\n\nconst game = new Phaser.Game(gameConfig);\n\nexport { game };\n"],"names":["BootScene","Phaser","juanIdleUrl","juanRunUrl","juanJumpUrl","juanPunchUrl","juanUppercutUrl","juanAerialPunchUrl","juanGettingPunchedUrl","juanGettingPunchedStomachUrl","juanDodgeUrl","juanMatrixDodgeUrl","juanKipupUrl","punchSfxUrl","kickSfxUrl","powerUpSfxUrl","menuMusicUrl","serverLabBgUrl","overgrownCityBgUrl","overgrownCitySunsetBgUrl","versusBgUrl","juanMenuUrl","serverLabFloorUrl","overgrownGroundFloorUrl","overgrownFloatingPlatformUrl","floatingScaffoldingUrl","powerBoosterUrl","enemyIdleUrl","enemyRunningUrl","enemyPunchUrl","enemySidekickUrl","enemyGettingPunchedUrl","PreloadScene","barX","GAME_WIDTH","barY","GAME_HEIGHT","bgBar","progressBar","loadingText","percentText","value","particleGfx","enemySidekickTexture","aerialPunchTexture","matrixDodgeTexture","fontsToLoad","font","testText","MenuScene","__publicField","bg","_a","overlay","vignette","i","alpha","size","particles","title","label","index","y","centerX","centerY","frame","buttonText","hitArea","action","button","delay","container","padding","padding_y","x","width","height","borderColor","cornerColor","cornerSize","cornerOffset","graphics","isSelected","fillColor","fillAlpha","borderWidth","glowColor","startX","finalX","keyboard","muteX","muteY","_b","existingMusic","key","volume","CONFIG","DAMAGE","Player","scene","inputManager","originY","body","offsetX","offsetY","delta","warningChecker","timeUntilAttack","delayMs","successful","_delay","dodgeAnimations","randomIndex","animKey","punchPressed","uppercutPressed","isAttacking","isAirborne","attack","previousState","_c","shouldFlip","amount","attackerX","knockbackDirection","anim","currentFrame","hitboxWidth","hitboxHeight","hitboxX","hitboxY","healthBar","Enemy","movingLeft","movingRight","jumpRequested","attackType","callback","shake","right","pixels","_PowerBooster","playerSprite","boosterBar","originalScaleX","originalScaleY","PowerBooster","InputManager","axis","BoosterBar","progress","fillWidth","gradient","durationMs","_time","remainingSeconds","PauseMenu","canPauseCallback","panel","subtitle","hint","text","color","selected","prevIndex","prevButton","_d","_e","_f","_g","HealthBar","targetSprite","maxHealth","characterName","headOffset","newHealth","_delta","topOfHead","GameOverOverlay","winner","titleContent","titleColor","subtitleContent","AI_CONFIG","EnemyAIController","enemy","player","playerX","enemyX","distance","variance","_distance","retreatChance","newState","state","cooldownMs","GROUND_HEIGHT","GameScene","scale","countdownText","showNumber","enemyHealthBar","groundGfx","PLATFORM_COLLISION_WIDTH","platGfx","FLOATING_PLATFORM_OFFSET_Y","platformImage","floorImage","aiController","startY","booster","debugText","sprite","error","controller","attackHitbox","enemySprite","enemyBody","enemyLeft","enemyRight","enemyTop","enemyBottom","hitboxRight","hitboxBottom","damage","playerBody","playerLeft","playerRight","playerTop","playerBottom","minTime","timeUntil","VERSUS_DURATION_MS","VersusScene","StoryScene","CreditsScene","gameConfig"],"mappings":"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"}